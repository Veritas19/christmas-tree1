<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ç²’å­åœ£è¯æ ‘ Â· æ‰‹åŠ¿äº¤äº’</title>
  <style>
    :root{
      --bg0:#07060a; --bg1:#151018;
      --gold:#ffd36a; --gold2:#ffefb0;
      --red:#ff2a2a; --green:#1f6b3a;
    }
    html,body{
      margin:0;height:100%;
      background:radial-gradient(1200px 800px at 50% 35%, #211326 0%, var(--bg1) 35%, var(--bg0) 100%);
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC","Microsoft YaHei", Arial;
    }
    #wrap{position:fixed; inset:0;}
    canvas{display:block; width:100%; height:100%; touch-action:none;}

    /* é¡¶éƒ¨ UI */
    #ui{
      position:fixed; left:14px; top:14px; z-index:20;
      display:flex; flex-direction:column; gap:10px;
      min-width:min(360px, calc(100vw - 28px));
      pointer-events:auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-weight:800;
      letter-spacing:.2px;
      display:inline-flex; align-items:center; gap:8px;
      transition: transform .12s ease, background .18s ease, border-color .18s ease;
    }
    .btn:active{transform: scale(.98);}
    .btn.on{background: rgba(255,211,106,.12); border-color: rgba(255,211,106,.35);}
    .btn.flash{animation: flash 1.0s ease-in-out 0s 3;}
    @keyframes flash{0%,100%{box-shadow:none} 50%{box-shadow:0 0 0 3px rgba(255,211,106,.35), 0 0 18px rgba(255,211,106,.28)}}
    .hint{font-size:12px; line-height:1.35; color:rgba(255,255,255,.80);}
    .hint b{color:rgba(255,243,205,.95)}
    .file{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      border:1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.18);
    }
    input[type="file"]{max-width:220px; color:rgba(255,255,255,.88)}

    /* ä¸­é—´å¼€å§‹æŒ‰é’® */
    #startOverlay{
      position:fixed; inset:0; z-index:50;
      display:grid; place-items:center;
      background:
        radial-gradient(900px 700px at 50% 45%, rgba(255,211,106,.10) 0%, rgba(255,42,42,.06) 25%, rgba(0,0,0,.70) 70%),
        linear-gradient(180deg, rgba(10,7,14,.92), rgba(0,0,0,.94));
      transition: opacity .35s ease, visibility .35s ease;
    }
    #startOverlay.hide{opacity:0; visibility:hidden; pointer-events:none;}
    .startCard{
      width:min(560px, calc(100vw - 44px));
      border-radius:22px;
      padding:22px 18px 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      text-align:center;
      color:rgba(255,255,255,.93);
    }
    .startTitle{font-size:22px; font-weight:950; letter-spacing:.6px; margin:0 0 10px;}
    .startSub{margin:0 0 16px; font-size:13px; color:rgba(255,255,255,.78); line-height:1.5;}
    #startBtn{
      width:100%;
      border:none;
      cursor:pointer;
      padding:16px 18px;
      border-radius:18px;
      font-size:18px;
      font-weight:950;
      letter-spacing:.8px;
      color:#1b0f08;
      background: linear-gradient(90deg, #ffe08a, #ffd36a, #ffefb0);
      box-shadow: 0 12px 30px rgba(255,211,106,.22), inset 0 1px 0 rgba(255,255,255,.65);
      transition: transform .12s ease, filter .2s ease;
    }
    #startBtn:active{transform: scale(.985);}
    .smallTip{margin-top:12px; font-size:12px; color:rgba(255,255,255,.72);}
    .smallTip span{color:rgba(255,211,106,.92); font-weight:900;}

    /* Toast */
    #toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      z-index:60; pointer-events:none;
      background: rgba(0,0,0,.56);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:14px;
      font-size:13px;
      max-width:min(520px, calc(100vw - 28px));
      opacity:0; transition: opacity .25s ease;
    }
    #toast.show{opacity:1;}

    /* æ”¾å¤§ç…§ç‰‡ï¼šä¿è¯æ­£é¢å®Œæ•´æ¸…æ™° */
    #photoOverlay{
      position:fixed; inset:0; z-index:40;
      display:none; place-items:center;
      pointer-events:none;
    }
    #photoOverlay.show{display:grid;}
    #photoCard{
      width:min(86vw, 720px);
      height:min(68vh, 520px);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 22px 60px rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      transform: scale(.90);
      opacity:0;
      transition: transform .22s cubic-bezier(.2,.9,.25,1.1), opacity .18s ease;
    }
    #photoOverlay.show #photoCard{transform: scale(1); opacity:1;}
    #photoImg{width:100%; height:100%; object-fit:contain; background: rgba(0,0,0,.35);}
    body.photo-mode canvas{filter: blur(8px) brightness(1.08) saturate(1.08); transition: filter .18s ease;}
    body:not(.photo-mode) canvas{filter:none; transition: filter .18s ease;}
  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="ui">
    <div class="panel">
      <div class="row">
        <div id="camBtn" class="btn"><span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span></div>
        <div id="musicBtn" class="btn"><span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span></div>
        <div class="file">
          <span>ğŸ–¼ï¸ ä¸Šä¼ ç…§ç‰‡(â‰¤7)</span>
          <input id="fileInput" type="file" accept="image/*" multiple />
        </div>
      </div>
      <div class="hint" style="margin-top:8px">
        æ‰‹åŠ¿ï¼š<b>æ¡æ‹³</b>â†’åˆæ‹¢ï¼›<b>äº”æŒ‡å¼ å¼€</b>â†’æ•£å¼€ï¼›æ•£å¼€æ—¶<b>ç§»åŠ¨æ‰‹</b>â†’æ—‹è½¬è§†è§’ï¼›<br/>
        <b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b>â†’æŠ“å–æ”¾å¤§ç…§ç‰‡ï¼Œ<b>åˆ†å¼€</b>â†’å›åŸä½ã€‚
      </div>
    </div>
  </div>

  <div id="startOverlay">
    <div class="startCard">
      <h2 class="startTitle">âœ¨ åœ£è¯æ ‘ Â· å¼€å§‹ä½“éªŒ</h2>
      <p class="startSub">ç‚¹ä¸€æ¬¡å°±ä¼šå°è¯•æ’­æ”¾åœ£è¯BGMï¼Œå¹¶è¯·æ±‚æ‘„åƒå¤´æƒé™ç”¨äºæ‰‹åŠ¿äº¤äº’ã€‚<br/>ï¼ˆä¸æƒ³å¼€æ‘„åƒå¤´ä¹Ÿå¯ä»¥åªçœ‹è§†è§‰æ•ˆæœï¼‰</p>
      <button id="startBtn">å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰</button>
      <div class="smallTip">å»ºè®®ç”¨ <span>Chrome / Safari / Edge</span> æ‰“å¼€ï¼Œå…è®¸æ‘„åƒå¤´åä½“éªŒæœ€ä½³ã€‚</div>
    </div>
  </div>

  <div id="toast"></div>

  <div id="photoOverlay">
    <div id="photoCard"><img id="photoImg" alt="photo" /></div>
  </div>

  <!-- å…¬æœ‰é¢†åŸŸ BGMï¼ˆWikimedia Commonsï¼‰ -->
  <audio id="bgm" preload="auto" loop playsinline
    src="https://upload.wikimedia.org/wikipedia/commons/3/32/Carol_of_the_Bells_-_Concert_Band_-_United_States_Air_Force_Band_of_the_Rockies.mp3"></audio>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

    /* Toast */
    const toastEl = document.getElementById("toast");
    let toastTimer = null;
    function toast(msg, ms=1800){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.remove("show"), ms);
    }

    /* éŸ³ä¹ï¼šæ·¡å…¥æ·¡å‡ºæ›´ä¸æ»‘ */
    const bgm = document.getElementById("bgm");
    let musicOn = false;
    let musicFadeRAF = 0;
    function setMusic(on){
      musicOn = on;
      cancelAnimationFrame(musicFadeRAF);
      const target = on ? 0.85 : 0.0;
      const start = bgm.volume ?? 0;
      const t0 = performance.now();
      const dur = 450;
      const step = (t)=>{
        const p = Math.min(1, (t - t0) / dur);
        const s = p*p*(3-2*p);
        bgm.volume = start + (target - start) * s;
        if(p < 1) musicFadeRAF = requestAnimationFrame(step);
      };
      musicFadeRAF = requestAnimationFrame(step);

      if(on){
        bgm.muted = false;
        bgm.play().catch(()=>toast("å¦‚æœæ²¡å£°éŸ³ï¼šè¯·å†ç‚¹ä¸€æ¬¡â€œéŸ³ä¹ï¼šå¼€å¯â€æˆ–ç‚¹ä¸€ä¸‹é¡µé¢", 2400));
      }else{
        setTimeout(()=>{ try{ bgm.pause(); }catch{} }, 520);
      }
    }

    /* Three */
    const wrap = document.getElementById("wrap");
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.18;
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x07060a, 0.038);

    const camera = new THREE.PerspectiveCamera(48, window.innerWidth/window.innerHeight, 0.08, 80);
    camera.position.set(0, 2.5, 8.2);

    const rig = new THREE.Group();
    scene.add(rig);

    function applyResponsive(){
      const w = window.innerWidth, h = window.innerHeight;
      const aspect = w / h;
      const short = Math.min(w, h);
      const scale = THREE.MathUtils.clamp(short / 820, 0.78, 1.18);
      rig.scale.setScalar(scale);

      const isPhone = short < 520 || aspect < 0.75;
      camera.fov = isPhone ? 56 : 48;
      camera.position.z = isPhone ? 9.4 : 8.2;
      camera.position.y = isPhone ? 2.75 : 2.5;
      camera.updateProjectionMatrix();

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, isPhone ? 1.75 : 2));
    }

    /* Lightsï¼šæš–ã€ç”µå½±æ„Ÿ */
    scene.add(new THREE.AmbientLight(0xffe6b8, 0.58));

    const key = new THREE.DirectionalLight(0xfff0d6, 1.05);
    key.position.set(4, 6, 4);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0xffd36a, 0.55);
    rim.position.set(-5, 4, -4);
    scene.add(rim);

    const glowLight = new THREE.PointLight(0xffd36a, 1.0, 16, 2.0);
    glowLight.position.set(0, 3.2, 2.6);
    scene.add(glowLight);

    /* Tree: åˆ†æå±‚çº§ + å…‰é›¾ */
    const tree = new THREE.Group();
    rig.add(tree);

    const TREE_H = 5.2;
    const BASE_R = 2.0;

    const branchGeom = new THREE.BufferGeometry();
    const segs = [];
    const levels = 14, perLevel = 46;
    let seed = 1.234;
    const randn = (s)=>{ const x = Math.sin(s)*10000; return x - Math.floor(x); };

    for(let li=0; li<levels; li++){
      const y = (li/(levels-1)) * (TREE_H*0.92);
      const t = 1 - y/(TREE_H*0.92);
      const r = BASE_R * Math.pow(t, 0.55);
      for(let i=0;i<perLevel;i++){
        seed += 0.37;
        const a = (i/perLevel)*Math.PI*2 + randn(seed)*0.12;
        const len = 0.25 + randn(seed+2.1)*0.45;
        const sx = Math.cos(a)*r*0.82;
        const sz = Math.sin(a)*r*0.82;
        const ex = Math.cos(a)*(r + len);
        const ez = Math.sin(a)*(r + len);
        const ey = y + (0.04 + randn(seed+4.2)*0.12);
        segs.push(sx,y,sz, ex,ey,ez);
      }
    }
    branchGeom.setAttribute("position", new THREE.Float32BufferAttribute(segs,3));
    const branchMat = new THREE.LineBasicMaterial({ color:0x1f6b3a, transparent:true, opacity:0.70 });
    tree.add(new THREE.LineSegments(branchGeom, branchMat));

    // å…‰é›¾
    const fogCount = 1600;
    const fogPos = new Float32Array(fogCount*3);
    const fogSize = new Float32Array(fogCount);
    const fogSeed = new Float32Array(fogCount);
    for(let i=0;i<fogCount;i++){
      seed += 0.19;
      const y = Math.pow(randn(seed+1.1), 0.85) * (TREE_H*0.98);
      const t = 1 - y/(TREE_H*0.98);
      const r = BASE_R * Math.pow(t, 0.72) * (0.2 + randn(seed+2.2)*0.9);
      const a = randn(seed+3.3)*Math.PI*2;
      fogPos[i*3+0]=Math.cos(a)*r;
      fogPos[i*3+1]=y;
      fogPos[i*3+2]=Math.sin(a)*r;
      fogSize[i] = 8 + randn(seed+5.1)*20;
      fogSeed[i] = randn(seed+7.7);
    }
    const fogGeom = new THREE.BufferGeometry();
    fogGeom.setAttribute("position", new THREE.BufferAttribute(fogPos,3));
    fogGeom.setAttribute("aSize", new THREE.BufferAttribute(fogSize,1));
    fogGeom.setAttribute("aSeed", new THREE.BufferAttribute(fogSeed,1));
    const fogMat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{
        uTime:{value:0},
        uColor1:{value:new THREE.Color(0xffd36a)},
        uColor2:{value:new THREE.Color(0xffefb0)},
        uOpacity:{value:0.26}
      },
      vertexShader:`
        attribute float aSize; attribute float aSeed;
        uniform float uTime; varying float vSeed;
        void main(){
          vSeed=aSeed;
          vec3 p=position;
          float w=sin(uTime*0.8+aSeed*6.2831)*0.06;
          p.x+=w; p.z-=w*0.9;
          vec4 mv=modelViewMatrix*vec4(p,1.0);
          gl_Position=projectionMatrix*mv;
          gl_PointSize=aSize*(140.0/-mv.z);
        }`,
      fragmentShader:`
        uniform vec3 uColor1,uColor2; uniform float uOpacity;
        varying float vSeed;
        void main(){
          vec2 uv=gl_PointCoord*2.0-1.0;
          float d=dot(uv,uv);
          float a=smoothstep(1.0,0.0,d);
          a*=a;
          vec3 c=mix(uColor1,uColor2,vSeed);
          gl_FragColor=vec4(c,a*uOpacity);
        }`
    });
    tree.add(new THREE.Points(fogGeom, fogMat));

    /* é¡¶éƒ¨äº”è§’æ˜Ÿï¼šæ›´æ˜æ˜¾ã€è§’æ›´å¤§ */
    function makeStar(){
      const shape = new THREE.Shape();
      const spikes=5, outer=0.34, inner=0.14;
      let rot=Math.PI/2*3, cx=0, cy=0;
      shape.moveTo(cx, cy-outer);
      for(let i=0;i<spikes;i++){
        shape.lineTo(cx+Math.cos(rot)*outer, cy+Math.sin(rot)*outer); rot+=Math.PI/spikes;
        shape.lineTo(cx+Math.cos(rot)*inner, cy+Math.sin(rot)*inner); rot+=Math.PI/spikes;
      }
      shape.closePath();
      const geo = new THREE.ExtrudeGeometry(shape, {depth:0.08, bevelEnabled:true, bevelThickness:0.02, bevelSize:0.02, bevelSegments:2});
      geo.center();
      const mat = new THREE.MeshStandardMaterial({
        color:0xffd36a, metalness:0.95, roughness:0.18,
        emissive:new THREE.Color(0xffb84a), emissiveIntensity:0.95
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(0, TREE_H*0.98+0.25, 0);
      m.rotation.set(0.18, 0.0, 0.10);
      m.scale.setScalar(1.30);
      return m;
    }
    const star = makeStar();
    tree.add(star);

    /* ç¯ä¸²ï¼šåˆæ‹¢æ€æ ‡å‡†èºæ—‹é»„çº¿ï¼›æ•£å¼€æ€éšæ„æµåŠ¨ */
    function buildHelixPoints(standardness, time){
      const pts=[];
      const turns=6.2, steps=220;
      for(let i=0;i<=steps;i++){
        const u=i/steps;
        const y=0.25+u*(TREE_H*0.92);
        const t=1-y/(TREE_H*0.92);
        const rBase=BASE_R*Math.pow(t,0.65)*0.98;
        const a0=u*turns*Math.PI*2;
        const wob=(1-standardness);
        const n1=Math.sin(time*0.9+u*12.0)*0.18*wob;
        const n2=Math.cos(time*0.7+u*9.0)*0.14*wob;
        const r=rBase*(1+n1);
        const a=a0+n2;
        pts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r));
      }
      return pts;
    }
    const helixMat = new THREE.MeshBasicMaterial({ color:0xffd36a, transparent:true, opacity:0.88 });
    let helixMesh=null;

    function rebuildHelix(standardness, time){
      if(helixMesh) tree.remove(helixMesh);
      const curve = new THREE.CatmullRomCurve3(buildHelixPoints(standardness, time));
      const geo = new THREE.TubeGeometry(curve, 220, 0.018, 10, false);
      helixMesh = new THREE.Mesh(geo, helixMat);
      helixMesh.renderOrder = 1;
      tree.add(helixMesh);

      if(!rebuildHelix.lights){
        rebuildHelix.lights=[];
        const bulbG=new THREE.SphereGeometry(0.03, 12, 10);
        const bulbM=new THREE.MeshBasicMaterial({color:0xffefb0, transparent:true, opacity:0.96});
        for(let i=0;i<70;i++){
          const b=new THREE.Mesh(bulbG, bulbM);
          tree.add(b);
          rebuildHelix.lights.push(b);
        }
      }
      const pts = buildHelixPoints(1, time);
      rebuildHelix.lights.forEach((b,i)=>{
        const u=i/(rebuildHelix.lights.length-1);
        b.position.copy(pts[Math.floor(u*(pts.length-1))]);
      });
    }
    rebuildHelix(1,0);

    /* å…ƒç´ ï¼šåªè¦äº®é‡‘&äº®çº¢çƒ + å°‘é‡é‡‘ç«‹æ–¹ä½“ + 7å¼ ç…§ç‰‡ */
    const elements=[];
    const photoPlanes=[];
    const photoTex=[];
    const goldMat = new THREE.MeshStandardMaterial({ color:0xffd36a, metalness:0.95, roughness:0.18, emissive:new THREE.Color(0x2a1a06), emissiveIntensity:0.55 });
    const redMat  = new THREE.MeshStandardMaterial({ color:0xff2a2a, metalness:0.60, roughness:0.25, emissive:new THREE.Color(0x200008), emissiveIntensity:0.35 });

    const sphereG = new THREE.SphereGeometry(0.09,22,18);
    const cubeG   = new THREE.BoxGeometry(0.11,0.11,0.11);

    seed = 9.87;
    const BALLS=170;
    for(let i=0;i<BALLS;i++){
      const m = (i%2===0) ? goldMat : redMat;
      const mesh = new THREE.Mesh(sphereG, m);
      tree.add(mesh);
      elements.push({kind:"orn", obj:mesh, compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
        baseRot:new THREE.Euler(randn(seed+1)*0.6, randn(seed+2)*0.6, randn(seed+3)*0.6),
        wob:new THREE.Vector3(randn(seed+4), randn(seed+5), randn(seed+6))
      });
      seed += 0.41;
    }
    const CUBES=48;
    for(let i=0;i<CUBES;i++){
      const mesh = new THREE.Mesh(cubeG, goldMat);
      tree.add(mesh);
      elements.push({kind:"cube", obj:mesh, compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
        baseRot:new THREE.Euler(randn(seed+1)*0.8, randn(seed+2)*0.8, randn(seed+3)*0.8),
        wob:new THREE.Vector3(randn(seed+4), randn(seed+5), randn(seed+6))
      });
      seed += 0.53;
    }

    function makePhotoPlane(){
      const g = new THREE.PlaneGeometry(0.55, 0.38);
      const mat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.05, roughness:0.35, transparent:true, opacity:0.98 });
      const mesh = new THREE.Mesh(g, mat);
      mesh.renderOrder = 2;
      tree.add(mesh);
      const frameMat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.2, roughness:0.55, transparent:true, opacity:0.16 });
      const frame = new THREE.Mesh(new THREE.PlaneGeometry(0.59,0.42), frameMat);
      frame.position.z = -0.002;
      mesh.add(frame);
      return mesh;
    }
    for(let i=0;i<7;i++){
      const p = makePhotoPlane();
      photoPlanes.push(p);
      elements.push({kind:"photo", obj:p, compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
        wob:new THREE.Vector3(Math.random(),Math.random(),Math.random()), photoIndex:i
      });
    }

    function computeAnchors(num){
      const anchors=[];
      const golden=2.399963229728653;
      for(let i=0;i<num;i++){
        const y=(i/(num-1))*(TREE_H*0.78)+0.55;
        const t=1-(y/(TREE_H*0.98));
        const r=BASE_R*Math.pow(t,0.72)*0.92;
        const a=(i*golden)%(Math.PI*2);
        anchors.push({pos:new THREE.Vector3(Math.cos(a)*r,y,Math.sin(a)*r)});
      }
      return anchors;
    }

    function assignPositions(){
      // çƒ/ç«‹æ–¹ä½“
      for(const e of elements){
        if(e.kind==="photo") continue;
        seed += 0.37;
        const y=Math.pow(randn(seed+1.2),0.9)*(TREE_H*0.92);
        const t=1-y/(TREE_H*0.92);
        const r=BASE_R*Math.pow(t,0.75);
        const a=randn(seed+2.2)*Math.PI*2;
        e.compact.set(Math.cos(a)*r, y, Math.sin(a)*r);

        const sr=3.6+randn(seed+3.3)*2.2;
        const sa=randn(seed+4.4)*Math.PI*2;
        const sy=(randn(seed+5.5)-0.35)*3.1+1.1;
        e.scatter.set(Math.cos(sa)*sr, sy, Math.sin(sa)*sr);
      }

      // ç…§ç‰‡ï¼šåˆ†å±‚+å‘¨å‘å‡åŒ€
      const anchors = computeAnchors(7);
      for(let i=0;i<7;i++){
        const pe = elements.find(x=>x.kind==="photo" && x.photoIndex===i);
        pe.compact.copy(anchors[i].pos);
        const out = anchors[i].pos.clone().multiplyScalar(1.55);
        out.x += (i%2?0.55:-0.55);
        out.z += (i%2?-0.35:0.35);
        out.y += (i-3)*0.08;
        pe.scatter.copy(out);
      }
    }
    assignPositions();

    /* çŠ¶æ€æœº */
    const STATE={COMPACT:"compact", SCATTER:"scatter", PHOTO:"photo"};
    let state=STATE.COMPACT, stateTarget=STATE.COMPACT;
    let mix=0, mixVel=0;
    function goto(next){
      if(next===STATE.PHOTO){ stateTarget=STATE.SCATTER; state=STATE.PHOTO; }
      else { state=next; stateTarget=next; }
    }

    function smoothDamp(current, target, currentVelocity, smoothTime, dt){
      smoothTime=Math.max(0.0001,smoothTime);
      const omega=2/smoothTime;
      const x=omega*dt;
      const exp=1/(1+x+0.48*x*x+0.235*x*x*x);
      let change=current-target;
      const temp=(currentVelocity+omega*change)*dt;
      currentVelocity=(currentVelocity-omega*temp)*exp;
      const output=target+(change+temp)*exp;
      return {value:output, vel:currentVelocity};
    }

    /* æ”¾å¤§ç…§ç‰‡ï¼šDOMå±‚æ˜¾ç¤ºï¼ˆæ­£é¢å®Œæ•´é«˜æ¸…ï¼‰ */
    const photoOverlay=document.getElementById("photoOverlay");
    const photoImg=document.getElementById("photoImg");
    let grabbed=-1;
    function enterPhoto(i){
      grabbed=i;
      const tex=photoTex[i];
      if(tex?.image?.src) photoImg.src=tex.image.src;
      document.body.classList.add("photo-mode");
      photoOverlay.classList.add("show");
      goto(STATE.PHOTO);
    }
    function exitPhoto(){
      grabbed=-1;
      document.body.classList.remove("photo-mode");
      photoOverlay.classList.remove("show");
      if(state===STATE.PHOTO) goto(STATE.SCATTER);
    }

    /* ä¸Šä¼ ç…§ç‰‡ */
    const fileInput=document.getElementById("fileInput");
    const loader=new THREE.TextureLoader();
    function applyTex(i, tex){
      tex.colorSpace=THREE.SRGBColorSpace;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
      tex.minFilter=THREE.LinearMipmapLinearFilter;
      tex.magFilter=THREE.LinearFilter;
      tex.generateMipmaps=true;
      tex.needsUpdate=true;
      photoTex[i]=tex;
      const plane=photoPlanes[i];
      plane.material.map=tex;
      plane.material.needsUpdate=true;
    }
    function placeholder(i){
      const c=document.createElement("canvas");
      c.width=1024; c.height=768;
      const g=c.getContext("2d");
      const grd=g.createLinearGradient(0,0,1024,768);
      grd.addColorStop(0,"rgba(255,211,106,0.95)");
      grd.addColorStop(0.55,"rgba(255,42,42,0.85)");
      grd.addColorStop(1,"rgba(31,107,58,0.85)");
      g.fillStyle=grd; g.fillRect(0,0,c.width,c.height);
      g.fillStyle="rgba(0,0,0,.20)"; g.fillRect(40,40,c.width-80,c.height-80);
      g.fillStyle="rgba(255,255,255,.92)";
      g.font="bold 56px system-ui"; g.fillText("ä¸Šä¼ ç…§ç‰‡",80,180);
      g.font="36px system-ui"; g.fillStyle="rgba(255,255,255,.78)";
      g.fillText(`ç¬¬ ${i+1} å¼ `,80,250);
      g.fillText("Pinch æåˆæŠ“å–æ”¾å¤§",80,320);
      const t=new THREE.CanvasTexture(c);
      t.colorSpace=THREE.SRGBColorSpace;
      return t;
    }
    for(let i=0;i<7;i++) applyTex(i, placeholder(i));

    fileInput.addEventListener("change", async (e)=>{
      const files=Array.from(e.target.files||[]).slice(0,7);
      if(!files.length) return;
      toast(`å·²é€‰æ‹© ${files.length} å¼ ç…§ç‰‡`,1600);
      for(let i=0;i<7;i++){
        if(!files[i]) continue;
        const url=URL.createObjectURL(files[i]);
        await new Promise((resolve)=>{
          loader.load(url,(tex)=>{ applyTex(i,tex); resolve(); }, undefined, ()=>resolve());
        });
      }
      fileInput.value="";
    });

    /* ç›¸æœºæ—‹è½¬ï¼šæ›´è·Ÿæ‰‹ */
    let yaw=0, pitch=-0.08, roll=0;
    let yawT=0, pitchT=-0.08, rollT=0;
    function applyCamera(){
      const a=0.40;
      yaw += (yawT-yaw)*a;
      pitch += (pitchT-pitch)*a;
      roll += (rollT-roll)*0.25;
      pitch=THREE.MathUtils.clamp(pitch,-0.55,0.35);

      const radius=camera.position.z;
      const cx=0, cy=2.2, cz=0;
      camera.position.set(cx+Math.sin(yaw)*radius, cy+pitch*radius*0.9, cz+Math.cos(yaw)*radius);
      camera.lookAt(0,2.1,0);
      camera.rotation.z=roll;
    }

    /* æ‰‹åŠ¿ï¼šMediaPipe */
    const camBtn=document.getElementById("camBtn");
    const musicBtn=document.getElementById("musicBtn");
    const startOverlay=document.getElementById("startOverlay");
    const startBtn=document.getElementById("startBtn");

    let camOn=false, stream=null, videoEl=null, hands=null, mpCamera=null;

    // å»æŠ–ï¼šæ›´æ¸…æ¥šåˆ†è¾¨
    const hist=[], GH=10;
    function pushG(g){ hist.push(g); while(hist.length>GH) hist.shift(); }
    function stableG(){
      if(hist.length<GH) return null;
      const last=hist[hist.length-1];
      let same=0; for(const x of hist) if(x===last) same++;
      return same>=Math.floor(GH*0.7)? last : null;
    }
    function fingerExtended(lm, tip, pip){ return lm[tip].y < lm[pip].y - 0.02; }
    function countExtended(lm){
      const idx=fingerExtended(lm,8,6);
      const mid=fingerExtended(lm,12,10);
      const ring=fingerExtended(lm,16,14);
      const pin=fingerExtended(lm,20,18);
      const thumb=Math.abs(lm[4].x-lm[3].x)>0.025;
      return (idx?1:0)+(mid?1:0)+(ring?1:0)+(pin?1:0)+(thumb?1:0);
    }
    function isPinch(lm){
      const dx=lm[4].x-lm[8].x, dy=lm[4].y-lm[8].y;
      return Math.sqrt(dx*dx+dy*dy) < 0.045; // æ›´æ•æ„Ÿ
    }

    const raycaster=new THREE.Raycaster();
    function pickPhoto(nx, ny){
      raycaster.setFromCamera(new THREE.Vector2(nx, ny), camera);
      const hits=raycaster.intersectObjects(photoPlanes,true);
      if(hits?.length){
        const o=hits[0].object;
        const idx=photoPlanes.indexOf(o.parent?.isMesh?o.parent:o);
        if(idx>=0) return idx;
      }
      // å¦åˆ™ï¼šæœ€è¿‘â€œç£å¸â€
      let best=-1, bestD=1e9;
      const v=new THREE.Vector3();
      for(let i=0;i<photoPlanes.length;i++){
        v.copy(photoPlanes[i].getWorldPosition(new THREE.Vector3())).project(camera);
        const dx=v.x-nx, dy=v.y-ny;
        const d=dx*dx+dy*dy;
        if(d<bestD){bestD=d;best=i;}
      }
      return best;
    }

    let pinchPrev=false;
    let lastHand={x:0.5,y:0.5,t:0};

    function onHandResults(res){
      const ms=performance.now();
      const lm=res.multiHandLandmarks && res.multiHandLandmarks[0];
      if(!lm){ pushG("none"); return; }

      const wrist=lm[0];
      const hx=1-wrist.x; // é•œåƒæ›´ç›´è§‰
      const hy=wrist.y;

      const ext=countExtended(lm);
      const pinch=isPinch(lm);

      const isFist=(ext<=1)&&!pinch;
      const isOpen=(ext>=4)&&!pinch;

      let g="move";
      if(pinch) g="pinch";
      else if(isFist) g="fist";
      else if(isOpen) g="open";
      pushG(g);

      const stable=stableG();
      if(stable==="fist"){ exitPhoto(); goto(STATE.COMPACT); }
      else if(stable==="open"){ if(state!==STATE.PHOTO) goto(STATE.SCATTER); }

      // pinch è¿›å…¥/é€€å‡ºç…§ç‰‡æ€
      if(pinch && !pinchPrev){
        if(stateTarget!==STATE.COMPACT){
          const px=1-((lm[4].x+lm[8].x)*0.5);
          const py=((lm[4].y+lm[8].y)*0.5);
          const nx=THREE.MathUtils.clamp(px*2-1,-1,1);
          const ny=THREE.MathUtils.clamp(-(py*2-1),-1,1);
          const idx=pickPhoto(nx, ny);
          if(idx>=0){
            enterPhoto(idx);
            toast("å·²æŠ“å–ç…§ç‰‡ï¼šåˆ†å¼€æåˆå³å¯å›åˆ°åŸä½",1700);
          }
        }
      }
      if(!pinch && pinchPrev){ exitPhoto(); }
      pinchPrev=pinch;

      // æ•£å¼€æ€ + å¼ æ‰‹ + ç§»åŠ¨ => æ—‹è½¬è§†è§’ï¼ˆæ›´çµæ•ï¼šæ‘†ä¸€åœˆè½¬ä¸€åœˆï¼‰
      if(stateTarget===STATE.SCATTER && isOpen && !pinch && state!==STATE.PHOTO){
        const dx=hx-lastHand.x;
        const dy=hy-lastHand.y;
        if(Math.abs(dx)+Math.abs(dy)>0.002){
          const gainYaw=Math.PI*2.2;
          const gainPitch=Math.PI*1.1;
          yawT += dx*gainYaw;
          pitchT += dy*gainPitch;

          // roll è½»å¾®åŠ æˆï¼ˆæ‰‹æŒå€¾æ–œï¼‰
          const vx=(1-lm[17].x)-(1-lm[5].x);
          const vy=(lm[17].y)-(lm[5].y);
          const palmAngle=Math.atan2(vy,vx);
          rollT = THREE.MathUtils.clamp(palmAngle*0.15,-0.22,0.22);
        }
        lastHand={x:hx,y:hy,t:ms};
      }else{
        rollT *= 0.92;
      }
    }

    async function startCamera(){
      if(camOn) return true;
      try{
        if(!videoEl){
          videoEl=document.createElement("video");
          videoEl.setAttribute("playsinline","");
          videoEl.muted=true; videoEl.autoplay=true;
          videoEl.style.position="fixed"; videoEl.style.left="-9999px"; videoEl.style.top="-9999px";
          document.body.appendChild(videoEl);
        }
        stream = await navigator.mediaDevices.getUserMedia({
          video:{ facingMode:"user", width:{ideal:960}, height:{ideal:540} },
          audio:false
        });
        videoEl.srcObject=stream;
        await videoEl.play();

        if(!hands){
          hands=new window.Hands({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
          hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.70, minTrackingConfidence:0.70 });
          hands.onResults(onHandResults);
        }
        if(!mpCamera){
          mpCamera=new window.Camera(videoEl, {
            onFrame: async ()=>{ if(hands) await hands.send({image:videoEl}); },
            width:960, height:540
          });
        }
        mpCamera.start();

        camOn=true;
        camBtn.classList.add("on");
        camBtn.innerHTML="<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå¼€å¯</span>";
        toast("æ‘„åƒå¤´å·²å¼€å¯ï¼šç°åœ¨å¯ä»¥ç”¨æ‰‹åŠ¿æ§åˆ¶å•¦",1600);
        return true;
      }catch(e){
        camOn=false;
        camBtn.classList.remove("on");
        camBtn.innerHTML="<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span>";
        toast("æ‘„åƒå¤´å¼€å¯å¤±è´¥ï¼šè¯·æ£€æŸ¥æƒé™/ç”¨ HTTPS æ‰“å¼€",2400);
        return false;
      }
    }
    function stopCamera(){
      if(!camOn) return;
      try{ mpCamera?.stop?.(); }catch{}
      try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch{}
      stream=null; camOn=false;
      camBtn.classList.remove("on");
      camBtn.innerHTML="<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span>";
      toast("å·²å…³é—­æ‘„åƒå¤´",1200);
    }

    camBtn.addEventListener("click", async ()=>{ camOn? stopCamera(): await startCamera(); });

    musicBtn.addEventListener("click", ()=>{
      if(musicOn){
        setMusic(false);
        musicBtn.classList.remove("on");
        musicBtn.innerHTML="<span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span>";
      }else{
        setMusic(true);
        musicBtn.classList.add("on");
        musicBtn.innerHTML="<span>ğŸµ</span><span>éŸ³ä¹ï¼šå¼€å¯</span>";
      }
    });

    async function startExperience(){
      if(!musicOn){
        setMusic(true);
        musicBtn.classList.add("on");
        musicBtn.innerHTML="<span>ğŸµ</span><span>éŸ³ä¹ï¼šå¼€å¯</span>";
      }
      const ok = await startCamera();
      if(!ok){
        camBtn.classList.add("flash");
        toast("è¯·ç‚¹å·¦ä¸Šè§’â€œæ‘„åƒå¤´ï¼šå¼€å¯â€ï¼Œå¹¶å…è®¸æƒé™",2400);
        setTimeout(()=>camBtn.classList.remove("flash"), 3200);
      }
      startOverlay.classList.add("hide");
    }
    startBtn.addEventListener("click", startExperience);
    window.addEventListener("pointerdown", ()=>{
      if(musicOn && bgm.paused) bgm.play().catch(()=>{});
    }, {passive:true});

    /* åŠ¨ç”»æ›´æ–° */
    function update(dt, time){
      const targetMix = (stateTarget===STATE.SCATTER) ? 1 : 0;
      const sd = smoothDamp(mix, targetMix, mixVel, 0.38, dt);
      mix = sd.value; mixVel = sd.vel;

      // èºæ—‹ï¼šåˆæ‹¢æ ‡å‡†ï¼›æ•£å¼€éšæ„ï¼ˆå°‘é‡é‡å»ºï¼Œçœæ€§èƒ½ï¼‰
      update._acc = (update._acc||0)+dt;
      if(update._acc>0.085){
        update._acc=0;
        rebuildHelix(1-mix, time);
      }

      for(const e of elements){
        const obj=e.obj;
        const pos=e.compact.clone().lerp(e.scatter, mix);

        if(mix>0.02){
          const w=e.wob;
          pos.x += Math.sin(time*0.9+w.x*6.0)*0.08*mix;
          pos.y += Math.cos(time*0.8+w.y*6.0)*0.07*mix;
          pos.z += Math.sin(time*0.7+w.z*6.0)*0.08*mix;
        }

        if(e.kind==="photo" && grabbed===e.photoIndex){
          const toward = new THREE.Vector3().copy(camera.position).sub(obj.getWorldPosition(new THREE.Vector3())).normalize();
          pos.add(toward.multiplyScalar(0.55));
        }

        obj.position.lerp(pos, 0.18 + mix*0.08);

        if(e.kind==="photo"){
          const outward=obj.position.clone(); outward.y=obj.position.y;
          const look=outward.clone().multiplyScalar(2.0);
          obj.lookAt(look);
          obj.rotation.x += 0.18*(1-mix);
        }else{
          obj.rotation.x = e.baseRot.x + Math.sin(time*0.6+e.wob.x*6.0)*0.25*mix;
          obj.rotation.y = e.baseRot.y + Math.cos(time*0.55+e.wob.y*6.0)*0.22*mix;
          obj.rotation.z = e.baseRot.z + Math.sin(time*0.5+e.wob.z*6.0)*0.16*mix;
        }
      }

      star.rotation.y += dt*0.55*(0.2+(1-mix)*0.8);
      star.material.emissiveIntensity = 0.95 + Math.sin(time*1.6)*0.12;

      branchMat.opacity = 0.70 + (1-mix)*0.08;
      fogMat.uniforms.uTime.value=time;
      fogMat.uniforms.uOpacity.value = 0.26 + (1-mix)*0.08;
    }

    /* Resize */
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      applyResponsive();
    }
    window.addEventListener("resize", onResize, {passive:true});
    window.addEventListener("orientationchange", ()=>setTimeout(onResize,200), {passive:true});

    applyResponsive();
    goto(STATE.COMPACT);

    let last=performance.now();
    function tick(now){
      const dt=Math.min(0.033,(now-last)/1000);
      last=now;
      update(dt, now/1000);
      applyCamera();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
