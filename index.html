<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ç²’å­åœ£è¯æ ‘ Â· æ‰‹åŠ¿äº¤äº’</title>
  <style>
    :root{
      --bg0:#07060a; --bg1:#151018;
      --gold:#ffd36a; --gold2:#ffefb0;
      --red:#ff2a2a; --green:#1f6b3a;
    }
    html,body{
      margin:0;height:100%;
      background:radial-gradient(1200px 800px at 50% 35%, #211326 0%, var(--bg1) 35%, var(--bg0) 100%);
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC","Microsoft YaHei", Arial;
    }
    #wrap{position:fixed; inset:0;}
    canvas{display:block; width:100%; height:100%; touch-action:none;}

    #ui{
      position:fixed; left:14px; top:14px; z-index:20;
      display:flex; flex-direction:column; gap:10px;
      min-width:min(360px, calc(100vw - 28px));
      pointer-events:auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-weight:800;
      letter-spacing:.2px;
      display:inline-flex; align-items:center; gap:8px;
      transition: transform .12s ease, background .18s ease, border-color .18s ease;
    }
    .btn:active{transform: scale(.98);}
    .btn.on{background: rgba(255,211,106,.12); border-color: rgba(255,211,106,.35);}
    .hint{font-size:12px; line-height:1.35; color:rgba(255,255,255,.80);}
    .hint b{color:rgba(255,243,205,.95)}
    .file{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      border:1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.18);
    }
    input[type="file"]{max-width:220px; color:rgba(255,255,255,.88)}

    #startOverlay{
      position:fixed; inset:0; z-index:50;
      display:grid; place-items:center;
      background:
        radial-gradient(900px 700px at 50% 45%, rgba(255,211,106,.10) 0%, rgba(255,42,42,.06) 25%, rgba(0,0,0,.70) 70%),
        linear-gradient(180deg, rgba(10,7,14,.92), rgba(0,0,0,.94));
      transition: opacity .35s ease, visibility .35s ease;
    }
    #startOverlay.hide{opacity:0; visibility:hidden; pointer-events:none;}
    .startCard{
      width:min(560px, calc(100vw - 44px));
      border-radius:22px;
      padding:22px 18px 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      text-align:center;
      color:rgba(255,255,255,.93);
    }
    .startTitle{font-size:22px; font-weight:950; letter-spacing:.6px; margin:0 0 10px;}
    .startSub{margin:0 0 16px; font-size:13px; color:rgba(255,255,255,.78); line-height:1.5;}
    #startBtn{
      width:100%;
      border:none;
      cursor:pointer;
      padding:16px 18px;
      border-radius:18px;
      font-size:18px;
      font-weight:950;
      letter-spacing:.8px;
      color:#1b0f08;
      background: linear-gradient(90deg, #ffe08a, #ffd36a, #ffefb0);
      box-shadow: 0 12px 30px rgba(255,211,106,.22), inset 0 1px 0 rgba(255,255,255,.65);
      transition: transform .12s ease, filter .2s ease, opacity .2s ease;
    }
    #startBtn:active{transform: scale(.985);}
    #startBtn[disabled]{opacity:.75; cursor:not-allowed;}
    #startStatus{
      margin-top:10px;
      font-size:12px;
      color:rgba(255,255,255,.80);
      line-height:1.45;
      min-height:22px;
    }

    #toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      z-index:60; pointer-events:none;
      background: rgba(0,0,0,.56);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:14px;
      font-size:13px;
      max-width:min(560px, calc(100vw - 28px));
      opacity:0; transition: opacity .25s ease;
    }
    #toast.show{opacity:1;}

    #photoOverlay{
      position:fixed; inset:0; z-index:40;
      display:none; place-items:center;
      pointer-events:none;
    }
    #photoOverlay.show{display:grid;}
    #photoCard{
      width:min(86vw, 720px);
      height:min(68vh, 520px);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 22px 60px rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      transform: scale(.90);
      opacity:0;
      transition: transform .22s cubic-bezier(.2,.9,.25,1.1), opacity .18s ease;
    }
    #photoOverlay.show #photoCard{transform: scale(1); opacity:1;}
    #photoImg{width:100%; height:100%; object-fit:contain; background: rgba(0,0,0,.35);}
    body.photo-mode canvas{filter: blur(8px) brightness(1.08) saturate(1.08); transition: filter .18s ease;}
    body:not(.photo-mode) canvas{filter:none; transition: filter .18s ease;}
  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="ui">
    <div class="panel">
      <div class="row">
        <div id="camBtn" class="btn"><span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span></div>
        <div id="musicBtn" class="btn"><span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span></div>
        <div class="file">
          <span>ğŸ–¼ï¸ ä¸Šä¼ ç…§ç‰‡(â‰¤7)</span>
          <input id="fileInput" type="file" accept="image/*" multiple />
        </div>
      </div>
      <div class="hint" style="margin-top:8px">
        æ‰‹åŠ¿ï¼š<b>æ¡æ‹³</b>â†’åˆæ‹¢ï¼›<b>äº”æŒ‡å¼ å¼€</b>â†’æ•£å¼€ï¼›æ•£å¼€æ—¶<b>ç§»åŠ¨æ‰‹</b>â†’æ—‹è½¬è§†è§’ï¼›<br/>
        <b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b>â†’æŠ“å–æ”¾å¤§ç…§ç‰‡ï¼Œ<b>åˆ†å¼€</b>â†’å›åŸä½ã€‚<br/>
        ï¼ˆå¦‚æœæ‰‹åŠ¿åº“åŠ è½½å¤±è´¥ï¼Œä¹Ÿå¯ä»¥ç”¨<b>æ‰‹æŒ‡æ‹–åŠ¨</b>æ—‹è½¬è§†è§’ï¼‰
      </div>
    </div>
  </div>

  <div id="startOverlay">
    <div class="startCard">
      <h2 class="startTitle">âœ¨ åœ£è¯æ ‘ Â· å¼€å§‹ä½“éªŒ</h2>
      <p class="startSub">ç‚¹ä¸€æ¬¡å°±ä¼šå°è¯•æ’­æ”¾åœ£è¯BGMï¼Œå¹¶è¯·æ±‚æ‘„åƒå¤´æƒé™ç”¨äºæ‰‹åŠ¿äº¤äº’ã€‚<br/>ï¼ˆä¸æƒ³å¼€æ‘„åƒå¤´ä¹Ÿå¯ä»¥åªçœ‹è§†è§‰æ•ˆæœï¼‰</p>
      <button id="startBtn">å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰</button>
      <div id="startStatus"></div>
    </div>
  </div>

  <div id="toast"></div>

  <div id="photoOverlay">
    <div id="photoCard"><img id="photoImg" alt="photo" /></div>
  </div>

  <!-- å…¬æœ‰é¢†åŸŸ BGMï¼ˆWikimediaï¼‰ -->
  <audio id="bgm" preload="auto" loop playsinline
    src="https://upload.wikimedia.org/wikipedia/commons/3/32/Carol_of_the_Bells_-_Concert_Band_-_United_States_Air_Force_Band_of_the_Rockies.mp3"></audio>

  <!-- âœ… å…³é”®ï¼šThree.js ç›´æ¥ä»ä½ ä»“åº“æœ¬åœ°åŠ è½½ï¼ˆä¸èµ° CDNï¼‰ -->
  <script src="./libs/three.min.js"></script>

  <script>
    (function(){
      const toastEl = document.getElementById("toast");
      let toastTimer = null;
      function toast(msg, ms=2600){
        toastEl.textContent = msg;
        toastEl.classList.add("show");
        clearTimeout(toastTimer);
        toastTimer = setTimeout(()=>toastEl.classList.remove("show"), ms);
      }

      const startBtn = document.getElementById("startBtn");
      const startStatus = document.getElementById("startStatus");
      const startOverlay = document.getElementById("startOverlay");
      const camBtn = document.getElementById("camBtn");
      const musicBtn = document.getElementById("musicBtn");
      const fileInput = document.getElementById("fileInput");
      const bgm = document.getElementById("bgm");

      function setStatus(s){ startStatus.textContent = s; }

      window.addEventListener("error", (e)=>{
        toast("è„šæœ¬é”™è¯¯ï¼š" + (e?.message || "æœªçŸ¥é”™è¯¯"), 5200);
      });
      window.addEventListener("unhandledrejection", (e)=>{
        toast("è„šæœ¬å¼‚å¸¸ï¼š" + (e?.reason?.message || e?.reason || "æœªçŸ¥åŸå› "), 5200);
      });

      // âœ… å…³é”®æ£€æŸ¥ï¼šå¦‚æœè¿™é‡Œè¿˜æ˜¯æ²¡æœ‰ THREEï¼Œå°±è¯´æ˜ three.min.js æ²¡è¢«æ‰§è¡Œ
      if(!window.THREE){
        setStatus("æœªæ£€æµ‹åˆ° THREEï¼šè¯·ç¡®è®¤ libs/three.min.js æ–‡ä»¶åæ­£ç¡®ï¼Œä¸”å·²æäº¤åˆ°ä»“åº“ã€‚");
        toast("THREE æœªåŠ è½½ï¼šè¯·å¼ºåˆ¶åˆ·æ–°é¡µé¢ï¼ˆæ‰‹æœºå¯ç”¨æ— ç—•æ¨¡å¼æ‰“å¼€ï¼‰", 6000);
        return;
      }

      // ---- éŸ³ä¹æ·¡å…¥æ·¡å‡º ----
      let musicOn = false;
      let fadeRAF = 0;
      function setMusic(on){
        musicOn = on;
        cancelAnimationFrame(fadeRAF);
        const target = on ? 0.85 : 0.0;
        const start = (typeof bgm.volume === "number") ? bgm.volume : 0;
        const t0 = performance.now();
        const dur = 520;
        const step = (t)=>{
          const p = Math.min(1, (t - t0) / dur);
          const s = p*p*(3-2*p);
          bgm.volume = start + (target - start) * s;
          if(p < 1) fadeRAF = requestAnimationFrame(step);
        };
        fadeRAF = requestAnimationFrame(step);

        if(on){
          bgm.muted = false;
          bgm.play().catch(()=>toast("éŸ³ä¹æœªèƒ½è‡ªåŠ¨æ’­æ”¾ï¼šè¯·å†ç‚¹ä¸€ä¸‹é¡µé¢æˆ–ç‚¹å·¦ä¸Šè§’â€œéŸ³ä¹ï¼šå¼€å¯â€", 3500));
        }else{
          setTimeout(()=>{ try{ bgm.pause(); }catch{} }, 620);
        }
      }
      function updateMusicUI(){
        if(musicOn){
          musicBtn.classList.add("on");
          musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå¼€å¯</span>";
        }else{
          musicBtn.classList.remove("on");
          musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span>";
        }
      }

      // ---- æ‘„åƒå¤´ï¼ˆå…ˆåªåšæƒé™ + å¼€å…³ï¼›æ‰‹åŠ¿åº“åç»­å†åšæœ¬åœ°å…œåº•æ—¶åŠ å›ï¼‰----
      let camOn=false, stream=null, videoEl=null;
      function updateCamUI(){
        if(camOn){
          camBtn.classList.add("on");
          camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå¼€å¯</span>";
        }else{
          camBtn.classList.remove("on");
          camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span>";
        }
      }
      async function startCamera(){
        if(camOn) return true;
        try{
          if(!navigator.mediaDevices?.getUserMedia){
            toast("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ï¼šè¯·ç”¨ Safari/Chrome", 4500);
            return false;
          }
          if(!videoEl){
            videoEl=document.createElement("video");
            videoEl.setAttribute("playsinline","");
            videoEl.muted=true; videoEl.autoplay=true;
            videoEl.style.position="fixed";
            videoEl.style.left="-9999px";
            videoEl.style.top="-9999px";
            document.body.appendChild(videoEl);
          }
          stream = await navigator.mediaDevices.getUserMedia({
            video:{ facingMode:"user", width:{ideal:960}, height:{ideal:540} },
            audio:false
          });
          videoEl.srcObject=stream;
          await videoEl.play();
          camOn=true; updateCamUI();
          toast("æ‘„åƒå¤´å·²å¼€å¯ï¼ˆæ‰‹åŠ¿åº“è‹¥è¢«ç½‘ç»œæ‹¦æˆªï¼Œå¯å…ˆç”¨æ‹–åŠ¨å±å¹•æ—‹è½¬ï¼‰", 2500);
          return true;
        }catch(e){
          camOn=false; updateCamUI();
          toast("æ‘„åƒå¤´å¼€å¯å¤±è´¥ï¼šè¯·å…è®¸æƒé™ï¼›å°½é‡åˆ«åœ¨å¾®ä¿¡å†…æ‰“å¼€", 4500);
          return false;
        }
      }
      function stopCamera(){
        if(!camOn) return;
        try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch{}
        stream=null; camOn=false; updateCamUI();
        toast("å·²å…³é—­æ‘„åƒå¤´", 1200);
      }

      camBtn.addEventListener("click", async ()=>{ camOn ? stopCamera() : await startCamera(); });
      musicBtn.addEventListener("click", ()=>{ setMusic(!musicOn); updateMusicUI(); });

      // ---- Three.js åœºæ™¯ï¼ˆå†™å®æš–è‰² + äº®é‡‘/äº®çº¢çƒ + é¡¶éƒ¨æ˜Ÿ + åˆæ‹¢æ ‡å‡†èºæ—‹ç¯çº¿ï¼‰----
      const THREE = window.THREE;
      const wrap = document.getElementById("wrap");

      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.18;
      wrap.innerHTML="";
      wrap.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x07060a, 0.038);

      const camera = new THREE.PerspectiveCamera(48, window.innerWidth/window.innerHeight, 0.08, 80);
      camera.position.set(0, 2.5, 8.2);

      const rig = new THREE.Group();
      scene.add(rig);

      function applyResponsive(){
        const w = window.innerWidth, h = window.innerHeight;
        const aspect = w / h;
        const short = Math.min(w, h);
        const scale = THREE.MathUtils.clamp(short / 820, 0.78, 1.18);
        rig.scale.setScalar(scale);

        const isPhone = short < 520 || aspect < 0.75;
        camera.fov = isPhone ? 56 : 48;
        camera.position.z = isPhone ? 9.4 : 8.2;
        camera.position.y = isPhone ? 2.75 : 2.5;
        camera.updateProjectionMatrix();

        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isPhone ? 1.75 : 2));
      }

      // æš–è‰²â€œç”µå½±æ„Ÿâ€
      scene.add(new THREE.AmbientLight(0xffe6b8, 0.58));
      const key = new THREE.DirectionalLight(0xfff0d6, 1.05); key.position.set(4,6,4); scene.add(key);
      const rim = new THREE.DirectionalLight(0xffd36a, 0.55); rim.position.set(-5,4,-4); scene.add(rim);
      const glow = new THREE.PointLight(0xffd36a, 1.0, 16, 2.0); glow.position.set(0,3.2,2.6); scene.add(glow);

      const tree = new THREE.Group(); rig.add(tree);
      const TREE_H = 5.2, BASE_R = 2.0;

      // åˆ†æå±‚çº§ï¼ˆçº¿ï¼‰
      const branchGeom = new THREE.BufferGeometry();
      const segs = [];
      let seed = 1.234;
      const randn = (s)=>{ const x = Math.sin(s)*10000; return x - Math.floor(x); };
      const levels = 14, perLevel = 46;
      for(let li=0; li<levels; li++){
        const y = (li/(levels-1)) * (TREE_H*0.92);
        const t = 1 - y/(TREE_H*0.92);
        const r = BASE_R * Math.pow(t, 0.55);
        for(let i=0;i<perLevel;i++){
          seed += 0.37;
          const a = (i/perLevel)*Math.PI*2 + randn(seed)*0.12;
          const len = 0.25 + randn(seed+2.1)*0.45;
          const sx = Math.cos(a)*r*0.82;
          const sz = Math.sin(a)*r*0.82;
          const ex = Math.cos(a)*(r + len);
          const ez = Math.sin(a)*(r + len);
          const ey = y + (0.04 + randn(seed+4.2)*0.12);
          segs.push(sx,y,sz, ex,ey,ez);
        }
      }
      branchGeom.setAttribute("position", new THREE.Float32BufferAttribute(segs,3));
      const branchMat = new THREE.LineBasicMaterial({ color:0x1f6b3a, transparent:true, opacity:0.70 });
      tree.add(new THREE.LineSegments(branchGeom, branchMat));

      // å…‰é›¾ï¼ˆä½“ç§¯æ„Ÿï¼‰
      const fogCount = 1600;
      const fogPos = new Float32Array(fogCount*3);
      const fogSize = new Float32Array(fogCount);
      const fogSeed = new Float32Array(fogCount);
      for(let i=0;i<fogCount;i++){
        seed += 0.19;
        const y = Math.pow(randn(seed+1.1), 0.85) * (TREE_H*0.98);
        const t = 1 - y/(TREE_H*0.98);
        const r = BASE_R * Math.pow(t, 0.72) * (0.2 + randn(seed+2.2)*0.9);
        const a = randn(seed+3.3)*Math.PI*2;
        fogPos[i*3+0]=Math.cos(a)*r;
        fogPos[i*3+1]=y;
        fogPos[i*3+2]=Math.sin(a)*r;
        fogSize[i] = 8 + randn(seed+5.1)*20;
        fogSeed[i] = randn(seed+7.7);
      }
      const fogGeom = new THREE.BufferGeometry();
      fogGeom.setAttribute("position", new THREE.BufferAttribute(fogPos,3));
      fogGeom.setAttribute("aSize", new THREE.BufferAttribute(fogSize,1));
      fogGeom.setAttribute("aSeed", new THREE.BufferAttribute(fogSeed,1));
      const fogMat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{
          uTime:{value:0},
          uColor1:{value:new THREE.Color(0xffd36a)},
          uColor2:{value:new THREE.Color(0xffefb0)},
          uOpacity:{value:0.26}
        },
        vertexShader:`
          attribute float aSize; attribute float aSeed;
          uniform float uTime; varying float vSeed;
          void main(){
            vSeed=aSeed;
            vec3 p=position;
            float w=sin(uTime*0.8+aSeed*6.2831)*0.06;
            p.x+=w; p.z-=w*0.9;
            vec4 mv=modelViewMatrix*vec4(p,1.0);
            gl_Position=projectionMatrix*mv;
            gl_PointSize=aSize*(140.0/-mv.z);
          }`,
        fragmentShader:`
          uniform vec3 uColor1,uColor2; uniform float uOpacity;
          varying float vSeed;
          void main(){
            vec2 uv=gl_PointCoord*2.0-1.0;
            float d=dot(uv,uv);
            float a=smoothstep(1.0,0.0,d);
            a*=a;
            vec3 c=mix(uColor1,uColor2,vSeed);
            gl_FragColor=vec4(c,a*uOpacity);
          }`
      });
      tree.add(new THREE.Points(fogGeom, fogMat));

      // é¡¶éƒ¨äº”è§’æ˜Ÿï¼ˆæ›´æ˜æ˜¾ï¼‰
      function makeStar(){
        const shape = new THREE.Shape();
        const spikes=5, outer=0.34, inner=0.14;
        let rot=Math.PI/2*3, cx=0, cy=0;
        shape.moveTo(cx, cy-outer);
        for(let i=0;i<spikes;i++){
          shape.lineTo(cx+Math.cos(rot)*outer, cy+Math.sin(rot)*outer); rot+=Math.PI/spikes;
          shape.lineTo(cx+Math.cos(rot)*inner, cy+Math.sin(rot)*inner); rot+=Math.PI/spikes;
        }
        shape.closePath();
        const geo = new THREE.ExtrudeGeometry(shape, {depth:0.08, bevelEnabled:true, bevelThickness:0.02, bevelSize:0.02, bevelSegments:2});
        geo.center();
        const mat = new THREE.MeshStandardMaterial({
          color:0xffd36a, metalness:0.95, roughness:0.18,
          emissive:new THREE.Color(0xffb84a), emissiveIntensity:0.95
        });
        const m = new THREE.Mesh(geo, mat);
        m.position.set(0, TREE_H*0.98+0.25, 0);
        m.rotation.set(0.18, 0.0, 0.10);
        m.scale.setScalar(1.30);
        return m;
      }
      const star = makeStar();
      tree.add(star);

      // åˆæ‹¢æ€ï¼šæ ‡å‡†èºæ—‹é»„å…‰çº¿ï¼›æ•£å¼€æ€ï¼šæµåŠ¨
      let helixMesh=null;
      const helixMat = new THREE.MeshBasicMaterial({ color:0xffd36a, transparent:true, opacity:0.88 });
      function buildHelixPoints(standardness, time){
        const pts=[];
        const turns=6.2, steps=220;
        for(let i=0;i<=steps;i++){
          const u=i/steps;
          const y=0.25+u*(TREE_H*0.92);
          const t=1-y/(TREE_H*0.92);
          const rBase=BASE_R*Math.pow(t,0.65)*0.98;
          const a0=u*turns*Math.PI*2;
          const wob=(1-standardness);
          const n1=Math.sin(time*0.9+u*12.0)*0.18*wob;
          const n2=Math.cos(time*0.7+u*9.0)*0.14*wob;
          const r=rBase*(1+n1);
          const a=a0+n2;
          pts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r));
        }
        return pts;
      }
      function rebuildHelix(standardness, time){
        if(helixMesh) tree.remove(helixMesh);
        const curve = new THREE.CatmullRomCurve3(buildHelixPoints(standardness, time));
        const geo = new THREE.TubeGeometry(curve, 220, 0.018, 10, false);
        helixMesh = new THREE.Mesh(geo, helixMat);
        helixMesh.renderOrder = 1;
        tree.add(helixMesh);
      }
      rebuildHelix(1,0);

      // äº®é‡‘/äº®çº¢çƒ + é‡‘ç«‹æ–¹ä½“
      const elements=[];
      const photoPlanes=[];
      const photoTex=[];
      const goldMat = new THREE.MeshStandardMaterial({ color:0xffd36a, metalness:0.95, roughness:0.18, emissive:new THREE.Color(0x2a1a06), emissiveIntensity:0.55 });
      const redMat  = new THREE.MeshStandardMaterial({ color:0xff2a2a, metalness:0.60, roughness:0.25, emissive:new THREE.Color(0x200008), emissiveIntensity:0.35 });
      const sphereG = new THREE.SphereGeometry(0.09,22,18);
      const cubeG   = new THREE.BoxGeometry(0.11,0.11,0.11);

      seed = 9.87;
      for(let i=0;i<170;i++){
        const m = (i%2===0) ? goldMat : redMat;
        const mesh = new THREE.Mesh(sphereG, m);
        tree.add(mesh);
        elements.push({
          kind:"orn", obj:mesh,
          compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
          baseRot:new THREE.Euler(randn(seed+1)*0.6, randn(seed+2)*0.6, randn(seed+3)*0.6),
          wob:new THREE.Vector3(randn(seed+4), randn(seed+5), randn(seed+6))
        });
        seed += 0.41;
      }
      for(let i=0;i<48;i++){
        const mesh = new THREE.Mesh(cubeG, goldMat);
        tree.add(mesh);
        elements.push({
          kind:"cube", obj:mesh,
          compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
          baseRot:new THREE.Euler(randn(seed+1)*0.8, randn(seed+2)*0.8, randn(seed+3)*0.8),
          wob:new THREE.Vector3(randn(seed+4), randn(seed+5), randn(seed+6))
        });
        seed += 0.53;
      }

      // ç…§ç‰‡å¹³é¢ï¼ˆ7ï¼‰
      function makePhotoPlane(){
        const g = new THREE.PlaneGeometry(0.55, 0.38);
        const mat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.05, roughness:0.35, transparent:true, opacity:0.98 });
        const mesh = new THREE.Mesh(g, mat);
        mesh.renderOrder = 2;
        tree.add(mesh);
        const frameMat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.2, roughness:0.55, transparent:true, opacity:0.16 });
        const frame = new THREE.Mesh(new THREE.PlaneGeometry(0.59,0.42), frameMat);
        frame.position.z = -0.002;
        mesh.add(frame);
        return mesh;
      }
      for(let i=0;i<7;i++){
        const p = makePhotoPlane();
        photoPlanes.push(p);
        elements.push({kind:"photo", obj:p, compact:new THREE.Vector3(), scatter:new THREE.Vector3(), wob:new THREE.Vector3(Math.random(),Math.random(),Math.random()), photoIndex:i});
      }

      function computeAnchors(num){
        const anchors=[];
        const golden=2.399963229728653;
        for(let i=0;i<num;i++){
          const y=(i/(num-1))*(TREE_H*0.78)+0.55;
          const t=1-(y/(TREE_H*0.98));
          const r=BASE_R*Math.pow(t,0.72)*0.92;
          const a=(i*golden)%(Math.PI*2);
          anchors.push({pos:new THREE.Vector3(Math.cos(a)*r,y,Math.sin(a)*r)});
        }
        return anchors;
      }

      function assignPositions(){
        for(const e of elements){
          if(e.kind==="photo") continue;
          seed += 0.37;
          const y=Math.pow(randn(seed+1.2),0.9)*(TREE_H*0.92);
          const t=1-y/(TREE_H*0.92);
          const r=BASE_R*Math.pow(t,0.75);
          const a=randn(seed+2.2)*Math.PI*2;
          e.compact.set(Math.cos(a)*r, y, Math.sin(a)*r);

          const sr=3.6+randn(seed+3.3)*2.2;
          const sa=randn(seed+4.4)*Math.PI*2;
          const sy=(randn(seed+5.5)-0.35)*3.1+1.1;
          e.scatter.set(Math.cos(sa)*sr, sy, Math.sin(sa)*sr);
        }
        const anchors = computeAnchors(7);
        for(let i=0;i<7;i++){
          const pe = elements.find(x=>x.kind==="photo" && x.photoIndex===i);
          pe.compact.copy(anchors[i].pos);
          const out = anchors[i].pos.clone().multiplyScalar(1.55);
          out.x += (i%2?0.55:-0.55);
          out.z += (i%2?-0.35:0.35);
          out.y += (i-3)*0.08;
          pe.scatter.copy(out);
        }
      }
      assignPositions();

      // DOM æ”¾å¤§ç…§ç‰‡
      const photoOverlay=document.getElementById("photoOverlay");
      const photoImg=document.getElementById("photoImg");
      let grabbed=-1;
      function enterPhoto(i){
        grabbed=i;
        const tex=photoTex[i];
        if(tex && tex.image && tex.image.src) photoImg.src=tex.image.src;
        document.body.classList.add("photo-mode");
        photoOverlay.classList.add("show");
        state = "photo";
        stateTarget = "scatter";
      }
      function exitPhoto(){
        grabbed=-1;
        document.body.classList.remove("photo-mode");
        photoOverlay.classList.remove("show");
        if(state==="photo"){ state="scatter"; stateTarget="scatter"; }
      }

      // ä¸Šä¼ å›¾ç‰‡ï¼ˆå ä½ï¼‰
      const loader = new THREE.TextureLoader();
      function applyTex(i, tex){
        tex.colorSpace=THREE.SRGBColorSpace;
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
        tex.minFilter=THREE.LinearMipmapLinearFilter;
        tex.magFilter=THREE.LinearFilter;
        tex.generateMipmaps=true;
        tex.needsUpdate=true;
        photoTex[i]=tex;
        photoPlanes[i].material.map=tex;
        photoPlanes[i].material.needsUpdate=true;
      }
      function placeholder(i){
        const c=document.createElement("canvas");
        c.width=1024; c.height=768;
        const g=c.getContext("2d");
        const grd=g.createLinearGradient(0,0,1024,768);
        grd.addColorStop(0,"rgba(255,211,106,0.95)");
        grd.addColorStop(0.55,"rgba(255,42,42,0.85)");
        grd.addColorStop(1,"rgba(31,107,58,0.85)");
        g.fillStyle=grd; g.fillRect(0,0,c.width,c.height);
        g.fillStyle="rgba(0,0,0,.20)"; g.fillRect(40,40,c.width-80,c.height-80);
        g.fillStyle="rgba(255,255,255,.92)";
        g.font="bold 56px system-ui"; g.fillText("ä¸Šä¼ ç…§ç‰‡",80,180);
        g.font="36px system-ui"; g.fillStyle="rgba(255,255,255,.78)";
        g.fillText("ç¬¬ " + (i+1) + " å¼ ",80,250);
        g.fillText("ï¼ˆæåˆæ‰‹åŠ¿åç»­å¯åŠ æœ¬åœ°æ‰‹åŠ¿åº“ï¼‰",80,320);
        const t=new THREE.CanvasTexture(c);
        t.colorSpace=THREE.SRGBColorSpace;
        return t;
      }
      for(let i=0;i<7;i++) applyTex(i, placeholder(i));

      fileInput.addEventListener("change", async (e)=>{
        const files=Array.from(e.target.files||[]).slice(0,7);
        if(!files.length) return;
        toast("å·²é€‰æ‹© " + files.length + " å¼ ç…§ç‰‡", 1600);
        for(let i=0;i<7;i++){
          if(!files[i]) continue;
          const url=URL.createObjectURL(files[i]);
          await new Promise((resolve)=>{
            loader.load(url,(tex)=>{ applyTex(i,tex); resolve(); }, undefined, ()=>resolve());
          });
        }
        fileInput.value="";
      });

      // ç›¸æœºæ—‹è½¬ï¼ˆæ‹–åŠ¨å±å¹•ï¼‰
      let yaw=0, pitch=-0.08, roll=0;
      let yawT=0, pitchT=-0.08, rollT=0;
      function applyCamera(){
        const a=0.40;
        yaw += (yawT-yaw)*a;
        pitch += (pitchT-pitch)*a;
        roll += (rollT-roll)*0.25;
        pitch=THREE.MathUtils.clamp(pitch,-0.55,0.35);

        const radius=camera.position.z;
        const cx=0, cy=2.2, cz=0;
        camera.position.set(cx+Math.sin(yaw)*radius, cy+pitch*radius*0.9, cz+Math.cos(yaw)*radius);
        camera.lookAt(0,2.1,0);
        camera.rotation.z=roll;
      }

      // çŠ¶æ€æœº
      let state="compact", stateTarget="compact";
      let mix=0, mixVel=0;
      function smoothDamp(current, target, currentVelocity, smoothTime, dt){
        smoothTime=Math.max(0.0001,smoothTime);
        const omega=2/smoothTime;
        const x=omega*dt;
        const exp=1/(1+x+0.48*x*x+0.235*x*x*x);
        let change=current-target;
        const temp=(currentVelocity+omega*change)*dt;
        currentVelocity=(currentVelocity-omega*temp)*exp;
        const output=target+(change+temp)*exp;
        return {value:output, vel:currentVelocity};
      }

      // è§¦æ§æ‹–åŠ¨
      let dragging=false, lastX=0, lastY=0;
      renderer.domElement.addEventListener("pointerdown",(ev)=>{
        dragging=true; lastX=ev.clientX; lastY=ev.clientY;
      },{passive:true});
      window.addEventListener("pointerup",()=>dragging=false,{passive:true});
      window.addEventListener("pointermove",(ev)=>{
        if(!dragging) return;
        const dx=(ev.clientX-lastX)/Math.max(280, window.innerWidth);
        const dy=(ev.clientY-lastY)/Math.max(280, window.innerHeight);
        lastX=ev.clientX; lastY=ev.clientY;
        yawT += dx*(Math.PI*2.2);
        pitchT += dy*(Math.PI*1.1);
      },{passive:true});

      // resize
      function onResize(){
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        applyResponsive();
      }
      window.addEventListener("resize", onResize, {passive:true});
      window.addEventListener("orientationchange", ()=>setTimeout(onResize,200), {passive:true});
      applyResponsive();

      // å¾ªç¯
      let last=performance.now();
      function tick(now){
        const dt=Math.min(0.033,(now-last)/1000);
        last=now;

        const targetMix = (stateTarget==="scatter") ? 1 : 0;
        const sd = smoothDamp(mix, targetMix, mixVel, 0.38, dt);
        mix = sd.value; mixVel = sd.vel;

        // ç¯ä¸²ï¼šåˆæ‹¢æ€æ ‡å‡†èºæ—‹ï¼›æ•£å¼€æ€æµåŠ¨
        tick._acc = (tick._acc||0)+dt;
        if(tick._acc>0.085){
          tick._acc=0;
          rebuildHelix(1-mix, now/1000);
        }

        for(const e of elements){
          const obj=e.obj;
          const pos=e.compact.clone().lerp(e.scatter, mix);

          if(mix>0.02){
            const w=e.wob;
            pos.x += Math.sin(now*0.0009+w.x*6.0)*0.08*mix;
            pos.y += Math.cos(now*0.0008+w.y*6.0)*0.07*mix;
            pos.z += Math.sin(now*0.0007+w.z*6.0)*0.08*mix;
          }

          if(e.kind==="photo" && grabbed===e.photoIndex){
            const toward = new THREE.Vector3().copy(camera.position).sub(obj.getWorldPosition(new THREE.Vector3())).normalize();
            pos.add(toward.multiplyScalar(0.55));
          }

          obj.position.lerp(pos, 0.18 + mix*0.08);

          if(e.kind==="photo"){
            const outward=obj.position.clone(); outward.y=obj.position.y;
            const look=outward.clone().multiplyScalar(2.0);
            obj.lookAt(look);
            obj.rotation.x += 0.18*(1-mix);
          }else{
            obj.rotation.x = e.baseRot.x + Math.sin(now*0.0006+e.wob.x*6.0)*0.25*mix;
            obj.rotation.y = e.baseRot.y + Math.cos(now*0.00055+e.wob.y*6.0)*0.22*mix;
            obj.rotation.z = e.baseRot.z + Math.sin(now*0.0005+e.wob.z*6.0)*0.16*mix;
          }
        }

        star.rotation.y += dt*0.55*(0.2+(1-mix)*0.8);
        star.material.emissiveIntensity = 0.95 + Math.sin(now*0.0016)*0.12;

        fogMat.uniforms.uTime.value = now/1000;
        fogMat.uniforms.uOpacity.value = 0.26 + (1-mix)*0.08;

        applyCamera();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      // ç‚¹å‡»é¡µé¢å°è¯•æ¢å¤éŸ³é¢‘ï¼ˆæ‰‹æœºéœ€è¦ï¼‰
      window.addEventListener("pointerdown", ()=>{
        if(musicOn && bgm.paused) bgm.play().catch(()=>{});
      }, {passive:true});

      // å¼€å§‹ä½“éªŒæŒ‰é’®ï¼šä¸€å®šæœ‰åé¦ˆ & ä¸€å®šä¼šå…³æ‰é®ç½©
      startBtn.addEventListener("click", async ()=>{
        startBtn.disabled=true;
        startBtn.textContent="å¯åŠ¨ä¸­â€¦";
        setStatus("å·²æ”¶åˆ°ç‚¹å‡»ï¼šæ­£åœ¨å¼€å¯éŸ³ä¹ä¸æ‘„åƒå¤´æƒé™â€¦");

        if(!musicOn){ setMusic(true); updateMusicUI(); }

        // ä½ è¦æ±‚ï¼šç‚¹ä¸€ä¸‹å°±å°è¯•å¼€æ‘„åƒå¤´
        await startCamera();

        // æ— è®ºæ‘„åƒå¤´æ˜¯å¦æˆåŠŸï¼Œéƒ½è¿›å…¥ä½“éªŒ
        startOverlay.classList.add("hide");
        startBtn.disabled=false;
        startBtn.textContent="å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰";
        toast("å·²è¿›å…¥ä½“éªŒï¼šå¯æ‹–åŠ¨å±å¹•æ—‹è½¬è§†è§’", 1800);
      });

      setStatus("å·²æ£€æµ‹åˆ° THREE âœ… ç°åœ¨ç‚¹æŒ‰é’®å³å¯å¼€å§‹ä½“éªŒã€‚");
      updateCamUI();
      updateMusicUI();
    })();
  </script>
</body>
</html>
