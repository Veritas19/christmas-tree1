<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ç²’å­åœ£è¯æ ‘ Â· æ‰‹åŠ¿äº¤äº’</title>
  <style>
    :root{
      --bg0:#07060a; --bg1:#151018;
      --gold:#ffd36a; --gold2:#ffefb0;
      --red:#ff2a2a; --green:#1f6b3a;
    }
    html,body{
      margin:0;height:100%;
      background:radial-gradient(1200px 800px at 50% 35%, #211326 0%, var(--bg1) 35%, var(--bg0) 100%);
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC","Microsoft YaHei", Arial;
    }
    #wrap{position:fixed; inset:0;}
    canvas{display:block; width:100%; height:100%; touch-action:none;}

    #ui{
      position:fixed; left:14px; top:14px; z-index:20;
      display:flex; flex-direction:column; gap:10px;
      min-width:min(360px, calc(100vw - 28px));
      pointer-events:auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-weight:800;
      letter-spacing:.2px;
      display:inline-flex; align-items:center; gap:8px;
      transition: transform .12s ease, background .18s ease, border-color .18s ease;
    }
    .btn:active{transform: scale(.98);}
    .btn.on{background: rgba(255,211,106,.12); border-color: rgba(255,211,106,.35);}
    .btn.flash{animation: flash 1.0s ease-in-out 0s 3;}
    @keyframes flash{0%,100%{box-shadow:none} 50%{box-shadow:0 0 0 3px rgba(255,211,106,.35), 0 0 18px rgba(255,211,106,.28)}}
    .hint{font-size:12px; line-height:1.35; color:rgba(255,255,255,.80);}
    .hint b{color:rgba(255,243,205,.95)}
    .file{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      border:1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.18);
    }
    input[type="file"]{max-width:220px; color:rgba(255,255,255,.88)}

    #startOverlay{
      position:fixed; inset:0; z-index:50;
      display:grid; place-items:center;
      background:
        radial-gradient(900px 700px at 50% 45%, rgba(255,211,106,.10) 0%, rgba(255,42,42,.06) 25%, rgba(0,0,0,.70) 70%),
        linear-gradient(180deg, rgba(10,7,14,.92), rgba(0,0,0,.94));
      transition: opacity .35s ease, visibility .35s ease;
    }
    #startOverlay.hide{opacity:0; visibility:hidden; pointer-events:none;}
    .startCard{
      width:min(560px, calc(100vw - 44px));
      border-radius:22px;
      padding:22px 18px 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      text-align:center;
      color:rgba(255,255,255,.93);
    }
    .startTitle{font-size:22px; font-weight:950; letter-spacing:.6px; margin:0 0 10px;}
    .startSub{margin:0 0 16px; font-size:13px; color:rgba(255,255,255,.78); line-height:1.5;}
    #startBtn{
      width:100%;
      border:none;
      cursor:pointer;
      padding:16px 18px;
      border-radius:18px;
      font-size:18px;
      font-weight:950;
      letter-spacing:.8px;
      color:#1b0f08;
      background: linear-gradient(90deg, #ffe08a, #ffd36a, #ffefb0);
      box-shadow: 0 12px 30px rgba(255,211,106,.22), inset 0 1px 0 rgba(255,255,255,.65);
      transition: transform .12s ease, filter .2s ease, opacity .2s ease;
    }
    #startBtn:active{transform: scale(.985);}
    #startBtn[disabled]{opacity:.75; cursor:not-allowed;}
    .smallTip{margin-top:12px; font-size:12px; color:rgba(255,255,255,.72);}
    .smallTip span{color:rgba(255,211,106,.92); font-weight:900;}
    #startStatus{
      margin-top:10px;
      font-size:12px;
      color:rgba(255,255,255,.80);
      line-height:1.45;
      min-height:22px;
    }

    #toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      z-index:60; pointer-events:none;
      background: rgba(0,0,0,.56);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:14px;
      font-size:13px;
      max-width:min(560px, calc(100vw - 28px));
      opacity:0; transition: opacity .25s ease;
    }
    #toast.show{opacity:1;}

    #photoOverlay{
      position:fixed; inset:0; z-index:40;
      display:none; place-items:center;
      pointer-events:none;
    }
    #photoOverlay.show{display:grid;}
    #photoCard{
      width:min(86vw, 720px);
      height:min(68vh, 520px);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 22px 60px rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      transform: scale(.90);
      opacity:0;
      transition: transform .22s cubic-bezier(.2,.9,.25,1.1), opacity .18s ease;
    }
    #photoOverlay.show #photoCard{transform: scale(1); opacity:1;}
    #photoImg{width:100%; height:100%; object-fit:contain; background: rgba(0,0,0,.35);}
    body.photo-mode canvas{filter: blur(8px) brightness(1.08) saturate(1.08); transition: filter .18s ease;}
    body:not(.photo-mode) canvas{filter:none; transition: filter .18s ease;}
  </style>
</head>

<body>
  <div id="wrap"></div>

  <div id="ui">
    <div class="panel">
      <div class="row">
        <div id="camBtn" class="btn"><span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span></div>
        <div id="musicBtn" class="btn"><span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span></div>
        <div class="file">
          <span>ğŸ–¼ï¸ ä¸Šä¼ ç…§ç‰‡(â‰¤7)</span>
          <input id="fileInput" type="file" accept="image/*" multiple />
        </div>
      </div>
      <div class="hint" style="margin-top:8px">
        æ‰‹åŠ¿ï¼š<b>æ¡æ‹³</b>â†’åˆæ‹¢ï¼›<b>äº”æŒ‡å¼ å¼€</b>â†’æ•£å¼€ï¼›æ•£å¼€æ—¶<b>ç§»åŠ¨æ‰‹</b>â†’æ—‹è½¬è§†è§’ï¼›<br/>
        <b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b>â†’æŠ“å–æ”¾å¤§ç…§ç‰‡ï¼Œ<b>åˆ†å¼€</b>â†’å›åŸä½ã€‚<br/>
        ï¼ˆå¦‚æœæ‰‹åŠ¿åº“åŠ è½½å¤±è´¥ï¼Œä¹Ÿå¯ä»¥ç”¨<b>æ‰‹æŒ‡æ‹–åŠ¨</b>æ—‹è½¬è§†è§’ï¼‰
      </div>
    </div>
  </div>

  <div id="startOverlay">
    <div class="startCard">
      <h2 class="startTitle">âœ¨ åœ£è¯æ ‘ Â· å¼€å§‹ä½“éªŒ</h2>
      <p class="startSub">ç‚¹ä¸€æ¬¡å°±ä¼šå°è¯•æ’­æ”¾åœ£è¯BGMï¼Œå¹¶è¯·æ±‚æ‘„åƒå¤´æƒé™ç”¨äºæ‰‹åŠ¿äº¤äº’ã€‚<br/>ï¼ˆä¸æƒ³å¼€æ‘„åƒå¤´ä¹Ÿå¯ä»¥åªçœ‹è§†è§‰æ•ˆæœï¼‰</p>
      <button id="startBtn">å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰</button>
      <div id="startStatus"></div>
      <div class="smallTip">å¦‚æœä½ æ˜¯åœ¨å¾®ä¿¡/QQå†…æ‰“å¼€ï¼šè¯·ç‚¹å³ä¸Šè§’ <span>ç”¨æµè§ˆå™¨æ‰“å¼€</span>ï¼ˆå†…ç½®æµè§ˆå™¨ç»å¸¸æ‹¦æ‘„åƒå¤´/éŸ³é¢‘/CDNï¼‰ã€‚</div>
    </div>
  </div>

  <div id="toast"></div>

  <div id="photoOverlay">
    <div id="photoCard"><img id="photoImg" alt="photo" /></div>
  </div>

  <!-- å…¬æœ‰é¢†åŸŸ BGM -->
  <audio id="bgm" preload="auto" loop playsinline
    src="https://upload.wikimedia.org/wikipedia/commons/3/32/Carol_of_the_Bells_-_Concert_Band_-_United_States_Air_Force_Band_of_the_Rockies.mp3"></audio>

  <script>
    (function(){
      const toastEl = document.getElementById("toast");
      let toastTimer = null;
      function toast(msg, ms=2600){
        toastEl.textContent = msg;
        toastEl.classList.add("show");
        clearTimeout(toastTimer);
        toastTimer = setTimeout(()=>toastEl.classList.remove("show"), ms);
      }

      const startBtn = document.getElementById("startBtn");
      const startStatus = document.getElementById("startStatus");
      const startOverlay = document.getElementById("startOverlay");
      const camBtn = document.getElementById("camBtn");
      const musicBtn = document.getElementById("musicBtn");
      const fileInput = document.getElementById("fileInput");
      const bgm = document.getElementById("bgm");

      function setStatus(s){ startStatus.textContent = s; }

      window.addEventListener("error", (e)=>{
        toast("è„šæœ¬é”™è¯¯ï¼š" + (e?.message || "æœªçŸ¥é”™è¯¯"), 5200);
      });
      window.addEventListener("unhandledrejection", (e)=>{
        toast("è„šæœ¬å¼‚å¸¸ï¼š" + (e?.reason?.message || e?.reason || "æœªçŸ¥åŸå› "), 5200);
      });

      // ---- ä¾èµ–åŠ è½½å™¨ï¼šæŒ‰é¡ºåºå°è¯•å¤šä¸ªåœ°å€ï¼Œå“ªä¸ªèƒ½é€šå°±ç”¨å“ªä¸ª ----
      function loadScript(url){
        return new Promise((resolve, reject)=>{
          const s = document.createElement("script");
          s.src = url;
          s.async = true;
          s.onload = ()=>resolve(url);
          s.onerror = ()=>reject(new Error("load failed: " + url));
          document.head.appendChild(s);
        });
      }
      async function loadFirst(urls, label){
        let lastErr = null;
        for(const u of urls){
          try{
            const ok = await loadScript(u);
            return ok;
          }catch(e){
            lastErr = e;
          }
        }
        throw lastErr || new Error(label + " all failed");
      }

      // Threeï¼šæœ¬åœ° /libs ä¼˜å…ˆï¼Œéšåå¤šä¸ª CDN
      const THREE_SOURCES = [
        "./libs/three.min.js",
        "https://unpkg.com/three@0.161.0/build/three.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.161.0/three.min.js",
        "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"
      ];

      // MediaPipeï¼ˆHands + camera_utilsï¼‰ä¹Ÿæ”¯æŒæœ¬åœ° /libs å…œåº•
      const MP_SETS = [
        {
          hands: "./libs/mediapipe/hands/hands.js",
          camera: "./libs/mediapipe/camera_utils/camera_utils.js",
          base: "./libs/mediapipe/hands/"
        },
        {
          hands: "https://unpkg.com/@mediapipe/hands/hands.js",
          camera: "https://unpkg.com/@mediapipe/camera_utils/camera_utils.js",
          base: "https://unpkg.com/@mediapipe/hands/"
        },
        {
          hands: "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
          camera: "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
          base: "https://cdn.jsdelivr.net/npm/@mediapipe/hands/"
        }
      ];

      async function loadMediaPipe(){
        let lastErr=null;
        for(const set of MP_SETS){
          try{
            await loadScript(set.hands);
            await loadScript(set.camera);
            return set.base;
          }catch(e){
            lastErr = e;
          }
        }
        throw lastErr || new Error("mediapipe failed");
      }

      // ---- éŸ³ä¹æ·¡å…¥æ·¡å‡ºï¼ˆæ›´ä¸æ»‘ï¼‰----
      let musicOn = false;
      let fadeRAF = 0;
      function setMusic(on){
        musicOn = on;
        cancelAnimationFrame(fadeRAF);
        const target = on ? 0.85 : 0.0;
        const start = (typeof bgm.volume === "number") ? bgm.volume : 0;
        const t0 = performance.now();
        const dur = 450;
        const step = (t)=>{
          const p = Math.min(1, (t - t0) / dur);
          const s = p*p*(3-2*p);
          bgm.volume = start + (target - start) * s;
          if(p < 1) fadeRAF = requestAnimationFrame(step);
        };
        fadeRAF = requestAnimationFrame(step);

        if(on){
          bgm.muted = false;
          bgm.play().catch(()=>toast("éŸ³ä¹æœªèƒ½è‡ªåŠ¨æ’­æ”¾ï¼šè¯·å†ç‚¹ä¸€ä¸‹é¡µé¢æˆ–ç‚¹â€œéŸ³ä¹ï¼šå¼€å¯â€", 3500));
        }else{
          setTimeout(()=>{ try{ bgm.pause(); }catch{} }, 520);
        }
      }
      function updateMusicUI(){
        if(musicOn){
          musicBtn.classList.add("on");
          musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå¼€å¯</span>";
        }else{
          musicBtn.classList.remove("on");
          musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span>";
        }
      }

      // ---- æ‘„åƒå¤´/æ‰‹åŠ¿ï¼ˆè‹¥ mediapipe åŠ è½½å¤±è´¥åˆ™é™çº§åˆ°è§¦æ§æ—‹è½¬ï¼‰----
      let camOn=false, stream=null, videoEl=null, hands=null, mpCamera=null;
      let mpBase = null;
      function updateCamUI(){
        if(camOn){
          camBtn.classList.add("on");
          camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå¼€å¯</span>";
        }else{
          camBtn.classList.remove("on");
          camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span>";
        }
      }

      // ---- Three åœºæ™¯å˜é‡ï¼ˆç¨å initï¼‰----
      let THREE=null, renderer=null, scene=null, camera=null, rig=null, tree=null;
      let photoPlanes=[], photoTex=[], elements=[];
      let state="compact", stateTarget="compact";
      let mix=0, mixVel=0;
      let yaw=0, pitch=-0.08, roll=0;
      let yawT=0, pitchT=-0.08, rollT=0;
      let grabbed=-1;

      const photoOverlay=document.getElementById("photoOverlay");
      const photoImg=document.getElementById("photoImg");
      function enterPhoto(i){
        grabbed=i;
        const tex=photoTex[i];
        if(tex?.image?.src) photoImg.src=tex.image.src;
        document.body.classList.add("photo-mode");
        photoOverlay.classList.add("show");
        state="photo"; stateTarget="scatter";
      }
      function exitPhoto(){
        grabbed=-1;
        document.body.classList.remove("photo-mode");
        photoOverlay.classList.remove("show");
        if(state==="photo"){ state="scatter"; stateTarget="scatter"; }
      }

      function smoothDamp(current, target, currentVelocity, smoothTime, dt){
        smoothTime=Math.max(0.0001,smoothTime);
        const omega=2/smoothTime;
        const x=omega*dt;
        const exp=1/(1+x+0.48*x*x+0.235*x*x*x);
        let change=current-target;
        const temp=(currentVelocity+omega*change)*dt;
        currentVelocity=(currentVelocity-omega*temp)*exp;
        const output=target+(change+temp)*exp;
        return {value:output, vel:currentVelocity};
      }

      function applyCamera(){
        const a=0.40;
        yaw += (yawT-yaw)*a;
        pitch += (pitchT-pitch)*a;
        roll += (rollT-roll)*0.25;
        pitch=THREE.MathUtils.clamp(pitch,-0.55,0.35);

        const radius=camera.position.z;
        const cx=0, cy=2.2, cz=0;
        camera.position.set(cx+Math.sin(yaw)*radius, cy+pitch*radius*0.9, cz+Math.cos(yaw)*radius);
        camera.lookAt(0,2.1,0);
        camera.rotation.z=roll;
      }

      function applyResponsive(){
        const w = window.innerWidth, h = window.innerHeight;
        const aspect = w / h;
        const short = Math.min(w, h);
        const scale = THREE.MathUtils.clamp(short / 820, 0.78, 1.18);
        rig.scale.setScalar(scale);

        const isPhone = short < 520 || aspect < 0.75;
        camera.fov = isPhone ? 56 : 48;
        camera.position.z = isPhone ? 9.4 : 8.2;
        camera.position.y = isPhone ? 2.75 : 2.5;
        camera.updateProjectionMatrix();

        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isPhone ? 1.75 : 2));
      }

      // ç¯ä¸²èºæ—‹ï¼šåˆæ‹¢æ ‡å‡†ï¼›æ•£å¼€æ›´æµåŠ¨
      const TREE_H=5.2, BASE_R=2.0;
      let helixMesh=null, helixMat=null;
      function buildHelixPoints(standardness, time){
        const pts=[];
        const turns=6.2, steps=220;
        for(let i=0;i<=steps;i++){
          const u=i/steps;
          const y=0.25+u*(TREE_H*0.92);
          const t=1-y/(TREE_H*0.92);
          const rBase=BASE_R*Math.pow(t,0.65)*0.98;
          const a0=u*turns*Math.PI*2;
          const wob=(1-standardness);
          const n1=Math.sin(time*0.9+u*12.0)*0.18*wob;
          const n2=Math.cos(time*0.7+u*9.0)*0.14*wob;
          const r=rBase*(1+n1);
          const a=a0+n2;
          pts.push(new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r));
        }
        return pts;
      }
      function rebuildHelix(standardness, time){
        if(!tree) return;
        if(helixMesh) tree.remove(helixMesh);
        const curve = new THREE.CatmullRomCurve3(buildHelixPoints(standardness, time));
        const geo = new THREE.TubeGeometry(curve, 220, 0.018, 10, false);
        helixMesh = new THREE.Mesh(geo, helixMat);
        helixMesh.renderOrder=1;
        tree.add(helixMesh);
      }

      // ä¸» initï¼šåˆ›å»º 3D
      function initThree(){
        const wrap = document.getElementById("wrap");

        renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.18;
        wrap.innerHTML="";
        wrap.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x07060a, 0.038);

        camera = new THREE.PerspectiveCamera(48, window.innerWidth/window.innerHeight, 0.08, 80);
        camera.position.set(0, 2.5, 8.2);

        rig = new THREE.Group();
        scene.add(rig);

        // æš–è‰²ç”µå½±æ„Ÿç¯å…‰
        scene.add(new THREE.AmbientLight(0xffe6b8, 0.58));
        const key = new THREE.DirectionalLight(0xfff0d6, 1.05); key.position.set(4,6,4); scene.add(key);
        const rim = new THREE.DirectionalLight(0xffd36a, 0.55); rim.position.set(-5,4,-4); scene.add(rim);
        const glow = new THREE.PointLight(0xffd36a, 1.0, 16, 2.0); glow.position.set(0,3.2,2.6); scene.add(glow);

        tree = new THREE.Group();
        rig.add(tree);

        // åˆ†æå±‚çº§ï¼ˆçº¿ï¼‰
        const branchGeom = new THREE.BufferGeometry();
        const segs = [];
        let seed = 1.234;
        const randn = (s)=>{ const x = Math.sin(s)*10000; return x - Math.floor(x); };
        const levels = 14, perLevel = 46;
        for(let li=0; li<levels; li++){
          const y = (li/(levels-1)) * (TREE_H*0.92);
          const t = 1 - y/(TREE_H*0.92);
          const r = BASE_R * Math.pow(t, 0.55);
          for(let i=0;i<perLevel;i++){
            seed += 0.37;
            const a = (i/perLevel)*Math.PI*2 + randn(seed)*0.12;
            const len = 0.25 + randn(seed+2.1)*0.45;
            const sx = Math.cos(a)*r*0.82;
            const sz = Math.sin(a)*r*0.82;
            const ex = Math.cos(a)*(r + len);
            const ez = Math.sin(a)*(r + len);
            const ey = y + (0.04 + randn(seed+4.2)*0.12);
            segs.push(sx,y,sz, ex,ey,ez);
          }
        }
        branchGeom.setAttribute("position", new THREE.Float32BufferAttribute(segs,3));
        const branchMat = new THREE.LineBasicMaterial({ color:0x1f6b3a, transparent:true, opacity:0.70 });
        tree.add(new THREE.LineSegments(branchGeom, branchMat));

        // å…‰é›¾ï¼ˆPoints Shaderï¼‰
        const fogCount = 1600;
        const fogPos = new Float32Array(fogCount*3);
        const fogSize = new Float32Array(fogCount);
        const fogSeed = new Float32Array(fogCount);
        for(let i=0;i<fogCount;i++){
          seed += 0.19;
          const y = Math.pow(randn(seed+1.1), 0.85) * (TREE_H*0.98);
          const t = 1 - y/(TREE_H*0.98);
          const r = BASE_R * Math.pow(t, 0.72) * (0.2 + randn(seed+2.2)*0.9);
          const a = randn(seed+3.3)*Math.PI*2;
          fogPos[i*3+0]=Math.cos(a)*r;
          fogPos[i*3+1]=y;
          fogPos[i*3+2]=Math.sin(a)*r;
          fogSize[i] = 8 + randn(seed+5.1)*20;
          fogSeed[i] = randn(seed+7.7);
        }
        const fogGeom = new THREE.BufferGeometry();
        fogGeom.setAttribute("position", new THREE.BufferAttribute(fogPos,3));
        fogGeom.setAttribute("aSize", new THREE.BufferAttribute(fogSize,1));
        fogGeom.setAttribute("aSeed", new THREE.BufferAttribute(fogSeed,1));
        const fogMat = new THREE.ShaderMaterial({
          transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
          uniforms:{
            uTime:{value:0},
            uColor1:{value:new THREE.Color(0xffd36a)},
            uColor2:{value:new THREE.Color(0xffefb0)},
            uOpacity:{value:0.26}
          },
          vertexShader:`
            attribute float aSize; attribute float aSeed;
            uniform float uTime; varying float vSeed;
            void main(){
              vSeed=aSeed;
              vec3 p=position;
              float w=sin(uTime*0.8+aSeed*6.2831)*0.06;
              p.x+=w; p.z-=w*0.9;
              vec4 mv=modelViewMatrix*vec4(p,1.0);
              gl_Position=projectionMatrix*mv;
              gl_PointSize=aSize*(140.0/-mv.z);
            }`,
          fragmentShader:`
            uniform vec3 uColor1,uColor2; uniform float uOpacity;
            varying float vSeed;
            void main(){
              vec2 uv=gl_PointCoord*2.0-1.0;
              float d=dot(uv,uv);
              float a=smoothstep(1.0,0.0,d);
              a*=a;
              vec3 c=mix(uColor1,uColor2,vSeed);
              gl_FragColor=vec4(c,a*uOpacity);
            }`
        });
        tree.add(new THREE.Points(fogGeom, fogMat));

        // é¡¶éƒ¨é‡‘è‰²äº”è§’æ˜Ÿï¼ˆæ›´æ˜æ˜¾ï¼‰
        function makeStar(){
          const shape = new THREE.Shape();
          const spikes=5, outer=0.34, inner=0.14;
          let rot=Math.PI/2*3, cx=0, cy=0;
          shape.moveTo(cx, cy-outer);
          for(let i=0;i<spikes;i++){
            shape.lineTo(cx+Math.cos(rot)*outer, cy+Math.sin(rot)*outer); rot+=Math.PI/spikes;
            shape.lineTo(cx+Math.cos(rot)*inner, cy+Math.sin(rot)*inner); rot+=Math.PI/spikes;
          }
          shape.closePath();
          const geo = new THREE.ExtrudeGeometry(shape, {depth:0.08, bevelEnabled:true, bevelThickness:0.02, bevelSize:0.02, bevelSegments:2});
          geo.center();
          const mat = new THREE.MeshStandardMaterial({
            color:0xffd36a, metalness:0.95, roughness:0.18,
            emissive:new THREE.Color(0xffb84a), emissiveIntensity:0.95
          });
          const m = new THREE.Mesh(geo, mat);
          m.position.set(0, TREE_H*0.98+0.25, 0);
          m.rotation.set(0.18, 0.0, 0.10);
          m.scale.setScalar(1.30);
          return m;
        }
        tree.add(makeStar());

        // æ ‡å‡†èºæ—‹é»„å…‰çº¿ï¼šåˆæ‹¢æ€æœ€æ ‡å‡†
        helixMat = new THREE.MeshBasicMaterial({ color:0xffd36a, transparent:true, opacity:0.88 });
        rebuildHelix(1, 0);

        // åªè¦äº®é‡‘è‰² & äº®çº¢è‰²çƒ
        elements = [];
        photoPlanes = [];
        photoTex = [];

        const goldMat = new THREE.MeshStandardMaterial({ color:0xffd36a, metalness:0.95, roughness:0.18, emissive:new THREE.Color(0x2a1a06), emissiveIntensity:0.55 });
        const redMat  = new THREE.MeshStandardMaterial({ color:0xff2a2a, metalness:0.60, roughness:0.25, emissive:new THREE.Color(0x200008), emissiveIntensity:0.35 });
        const sphereG = new THREE.SphereGeometry(0.09,22,18);
        const cubeG   = new THREE.BoxGeometry(0.11,0.11,0.11);

        // åˆ†å¸ƒç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼Œä½†ä¾ç„¶åˆ†å±‚/å‡åŒ€ï¼‰
        let seed2 = 9.87;
        const rand2 = (s)=>{ const x = Math.sin(s)*10000; return x - Math.floor(x); };

        function placeCompact(e){
          seed2 += 0.37;
          const y=Math.pow(rand2(seed2+1.2),0.9)*(TREE_H*0.92);
          const t=1-y/(TREE_H*0.92);
          const r=BASE_R*Math.pow(t,0.75);
          const a=rand2(seed2+2.2)*Math.PI*2;
          e.compact.set(Math.cos(a)*r, y, Math.sin(a)*r);
        }
        function placeScatter(e){
          const sr=3.6+rand2(seed2+3.3)*2.2;
          const sa=rand2(seed2+4.4)*Math.PI*2;
          const sy=(rand2(seed2+5.5)-0.35)*3.1+1.1;
          e.scatter.set(Math.cos(sa)*sr, sy, Math.sin(sa)*sr);
        }

        for(let i=0;i<170;i++){
          const m = (i%2===0) ? goldMat : redMat;
          const mesh = new THREE.Mesh(sphereG, m);
          tree.add(mesh);
          const e={kind:"orn", obj:mesh, compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
            baseRot:new THREE.Euler(rand2(seed2+1)*0.6, rand2(seed2+2)*0.6, rand2(seed2+3)*0.6),
            wob:new THREE.Vector3(rand2(seed2+4), rand2(seed2+5), rand2(seed2+6))
          };
          placeCompact(e); placeScatter(e);
          elements.push(e);
          seed2 += 0.41;
        }
        for(let i=0;i<48;i++){
          const mesh = new THREE.Mesh(cubeG, goldMat);
          tree.add(mesh);
          const e={kind:"cube", obj:mesh, compact:new THREE.Vector3(), scatter:new THREE.Vector3(),
            baseRot:new THREE.Euler(rand2(seed2+1)*0.8, rand2(seed2+2)*0.8, rand2(seed2+3)*0.8),
            wob:new THREE.Vector3(rand2(seed2+4), rand2(seed2+5), rand2(seed2+6))
          };
          placeCompact(e); placeScatter(e);
          elements.push(e);
          seed2 += 0.53;
        }

        // 7 å¼ ç…§ç‰‡
        function makePhotoPlane(){
          const g = new THREE.PlaneGeometry(0.55, 0.38);
          const mat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.05, roughness:0.35, transparent:true, opacity:0.98 });
          const mesh = new THREE.Mesh(g, mat);
          mesh.renderOrder=2;
          tree.add(mesh);
          const frameMat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.2, roughness:0.55, transparent:true, opacity:0.16 });
          const frame = new THREE.Mesh(new THREE.PlaneGeometry(0.59,0.42), frameMat);
          frame.position.z=-0.002;
          mesh.add(frame);
          return mesh;
        }
        function computeAnchors(num){
          const anchors=[];
          const golden=2.399963229728653;
          for(let i=0;i<num;i++){
            const y=(i/(num-1))*(TREE_H*0.78)+0.55;
            const t=1-(y/(TREE_H*0.98));
            const r=BASE_R*Math.pow(t,0.72)*0.92;
            const a=(i*golden)%(Math.PI*2);
            anchors.push(new THREE.Vector3(Math.cos(a)*r,y,Math.sin(a)*r));
          }
          return anchors;
        }
        const anchors = computeAnchors(7);
        for(let i=0;i<7;i++){
          const p = makePhotoPlane();
          photoPlanes.push(p);
          const e={kind:"photo", obj:p, compact:anchors[i].clone(), scatter:anchors[i].clone().multiplyScalar(1.55), wob:new THREE.Vector3(Math.random(),Math.random(),Math.random()), photoIndex:i};
          e.scatter.x += (i%2?0.55:-0.55);
          e.scatter.z += (i%2?-0.35:0.35);
          e.scatter.y += (i-3)*0.08;
          elements.push(e);
        }

        // å ä½å›¾
        function placeholder(i){
          const c=document.createElement("canvas");
          c.width=1024; c.height=768;
          const g=c.getContext("2d");
          const grd=g.createLinearGradient(0,0,1024,768);
          grd.addColorStop(0,"rgba(255,211,106,0.95)");
          grd.addColorStop(0.55,"rgba(255,42,42,0.85)");
          grd.addColorStop(1,"rgba(31,107,58,0.85)");
          g.fillStyle=grd; g.fillRect(0,0,c.width,c.height);
          g.fillStyle="rgba(0,0,0,.20)"; g.fillRect(40,40,c.width-80,c.height-80);
          g.fillStyle="rgba(255,255,255,.92)";
          g.font="bold 56px system-ui"; g.fillText("ä¸Šä¼ ç…§ç‰‡",80,180);
          g.font="36px system-ui"; g.fillStyle="rgba(255,255,255,.78)";
          g.fillText("ç¬¬ " + (i+1) + " å¼ ",80,250);
          g.fillText("Pinch æåˆæŠ“å–æ”¾å¤§",80,320);
          const t=new THREE.CanvasTexture(c);
          t.colorSpace=THREE.SRGBColorSpace;
          return t;
        }
        for(let i=0;i<7;i++){
          const t = placeholder(i);
          photoTex[i]=t;
          photoPlanes[i].material.map=t;
          photoPlanes[i].material.needsUpdate=true;
        }

        // ä¸Šä¼ ç…§ç‰‡
        const loader = new THREE.TextureLoader();
        function applyTex(i, tex){
          tex.colorSpace=THREE.SRGBColorSpace;
          tex.anisotropy = renderer.capabilities.getMaxAnisotropy ? renderer.capabilities.getMaxAnisotropy() : 1;
          tex.minFilter=THREE.LinearMipmapLinearFilter;
          tex.magFilter=THREE.LinearFilter;
          tex.generateMipmaps=true;
          tex.needsUpdate=true;
          photoTex[i]=tex;
          photoPlanes[i].material.map=tex;
          photoPlanes[i].material.needsUpdate=true;
        }
        fileInput.addEventListener("change", async (e)=>{
          const files=Array.from(e.target.files||[]).slice(0,7);
          if(!files.length) return;
          toast("å·²é€‰æ‹© " + files.length + " å¼ ç…§ç‰‡", 1600);
          for(let i=0;i<7;i++){
            if(!files[i]) continue;
            const url=URL.createObjectURL(files[i]);
            await new Promise((resolve)=>{
              loader.load(url,(tex)=>{ applyTex(i,tex); resolve(); }, undefined, ()=>resolve());
            });
          }
          fileInput.value="";
        });

        // è§¦æ§æ—‹è½¬å…œåº•ï¼ˆæ‰‹åŠ¿åº“æ²¡åŠ è½½ä¹Ÿèƒ½ç©ï¼‰
        let dragging=false, lastX=0, lastY=0;
        renderer.domElement.addEventListener("pointerdown",(ev)=>{
          dragging=true; lastX=ev.clientX; lastY=ev.clientY;
        },{passive:true});
        window.addEventListener("pointerup",()=>dragging=false,{passive:true});
        window.addEventListener("pointermove",(ev)=>{
          if(!dragging) return;
          const dx=(ev.clientX-lastX)/Math.max(280, window.innerWidth);
          const dy=(ev.clientY-lastY)/Math.max(280, window.innerHeight);
          lastX=ev.clientX; lastY=ev.clientY;
          // è·Ÿæ‰‹ï¼šæ‘†ä¸€åœˆè½¬ä¸€åœˆçš„æ‰‹æ„Ÿ
          yawT += dx*(Math.PI*2.2);
          pitchT += dy*(Math.PI*1.1);
        },{passive:true});

        // resize
        function onResize(){
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth/window.innerHeight;
          camera.updateProjectionMatrix();
          applyResponsive();
        }
        window.addEventListener("resize", onResize, {passive:true});
        window.addEventListener("orientationchange", ()=>setTimeout(onResize,200), {passive:true});
        applyResponsive();

        // render loop
        let last=performance.now();
        function tick(now){
          const dt=Math.min(0.033,(now-last)/1000);
          last=now;

          const targetMix = (stateTarget==="scatter") ? 1 : 0;
          const sd = smoothDamp(mix, targetMix, mixVel, 0.38, dt);
          mix = sd.value; mixVel = sd.vel;

          // ç¯ä¸²ï¼šåˆæ‹¢æ€æœ€æ ‡å‡†èºæ—‹ï¼Œæ•£å¼€æ€æ›´æµåŠ¨
          tick._acc = (tick._acc||0)+dt;
          if(tick._acc>0.085){
            tick._acc=0;
            rebuildHelix(1-mix, now/1000);
          }

          for(const e of elements){
            const obj=e.obj;
            const pos=e.compact.clone().lerp(e.scatter, mix);

            if(mix>0.02){
              const w=e.wob;
              pos.x += Math.sin(now*0.0009+w.x*6.0)*0.08*mix;
              pos.y += Math.cos(now*0.0008+w.y*6.0)*0.07*mix;
              pos.z += Math.sin(now*0.0007+w.z*6.0)*0.08*mix;
            }

            if(e.kind==="photo" && grabbed===e.photoIndex){
              const toward = new THREE.Vector3().copy(camera.position).sub(obj.getWorldPosition(new THREE.Vector3())).normalize();
              pos.add(toward.multiplyScalar(0.55));
            }

            obj.position.lerp(pos, 0.18 + mix*0.08);

            if(e.kind==="photo"){
              const outward=obj.position.clone(); outward.y=obj.position.y;
              const look=outward.clone().multiplyScalar(2.0);
              obj.lookAt(look);
              obj.rotation.x += 0.18*(1-mix);
            }else{
              obj.rotation.x = e.baseRot.x + Math.sin(now*0.0006+w.x*6.0)*0.25*mix;
              obj.rotation.y = e.baseRot.y + Math.cos(now*0.00055+w.y*6.0)*0.22*mix;
              obj.rotation.z = e.baseRot.z + Math.sin(now*0.0005+w.z*6.0)*0.16*mix;
            }
          }

          applyCamera();
          renderer.render(scene, camera);
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      }

      // ---- æ‰‹åŠ¿è¯†åˆ«ï¼ˆå¯ç”¨æ‰å¯ç”¨ï¼‰----
      const hist=[], GH=10;
      function pushG(g){ hist.push(g); while(hist.length>GH) hist.shift(); }
      function stableG(){
        if(hist.length<GH) return null;
        const last=hist[hist.length-1];
        let same=0; for(const x of hist) if(x===last) same++;
        return same>=Math.floor(GH*0.7)? last : null;
      }
      function fingerExtended(lm, tip, pip){ return lm[tip].y < lm[pip].y - 0.02; }
      function countExtended(lm){
        const idx=fingerExtended(lm,8,6);
        const mid=fingerExtended(lm,12,10);
        const ring=fingerExtended(lm,16,14);
        const pin=fingerExtended(lm,20,18);
        const thumb=Math.abs(lm[4].x-lm[3].x)>0.025;
        return (idx?1:0)+(mid?1:0)+(ring?1:0)+(pin?1:0)+(thumb?1:0);
      }
      function isPinch(lm){
        const dx=lm[4].x-lm[8].x, dy=lm[4].y-lm[8].y;
        return Math.sqrt(dx*dx+dy*dy) < 0.045;
      }

      let pinchPrev=false;
      let lastHand={x:0.5,y:0.5,t:0};

      // ç…§ç‰‡æ‹¾å–ï¼šä¼˜å…ˆå°„çº¿ï¼Œå¤±è´¥åˆ™æœ€è¿‘â€œç£å¸â€
      let raycaster=null;
      function pickPhoto(nx, ny){
        if(!raycaster) raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(nx, ny), camera);
        const hits=raycaster.intersectObjects(photoPlanes,true);
        if(hits?.length){
          const obj=hits[0].object;
          const idx=photoPlanes.indexOf(obj.parent?.isMesh ? obj.parent : obj);
          if(idx>=0) return idx;
        }
        let best=-1, bestD=1e9;
        const v=new THREE.Vector3();
        for(let i=0;i<photoPlanes.length;i++){
          v.copy(photoPlanes[i].getWorldPosition(new THREE.Vector3())).project(camera);
          const dx=v.x-nx, dy=v.y-ny;
          const d=dx*dx+dy*dy;
          if(d<bestD){bestD=d;best=i;}
        }
        return best;
      }

      function onHandResults(res){
        const lm = res.multiHandLandmarks && res.multiHandLandmarks[0];
        if(!lm){ pushG("none"); return; }

        const wrist=lm[0];
        const hx=1-wrist.x; // é•œåƒæ›´ç›´è§‰
        const hy=wrist.y;

        const ext=countExtended(lm);
        const pinch=isPinch(lm);
        const isFist=(ext<=1)&&!pinch;
        const isOpen=(ext>=4)&&!pinch;

        let g="move";
        if(pinch) g="pinch";
        else if(isFist) g="fist";
        else if(isOpen) g="open";
        pushG(g);

        const stable=stableG();
        if(stable==="fist"){ exitPhoto(); state="compact"; stateTarget="compact"; }
        else if(stable==="open"){ if(state!=="photo"){ state="scatter"; stateTarget="scatter"; } }

        if(pinch && !pinchPrev){
          if(stateTarget!=="compact"){
            const px=1-((lm[4].x+lm[8].x)*0.5);
            const py=((lm[4].y+lm[8].y)*0.5);
            const nx=Math.max(-1, Math.min(1, px*2-1));
            const ny=Math.max(-1, Math.min(1, -(py*2-1)));
            const idx=pickPhoto(nx, ny);
            if(idx>=0){
              enterPhoto(idx);
              toast("å·²æŠ“å–ç…§ç‰‡ï¼šåˆ†å¼€æåˆå³å¯å›åˆ°åŸä½",1700);
            }
          }
        }
        if(!pinch && pinchPrev){ exitPhoto(); }
        pinchPrev=pinch;

        // æ—‹è½¬è§†è§’ï¼šæ•£å¼€æ€ + å¼ æ‰‹ + ç§»åŠ¨ï¼ˆæ›´è·Ÿæ‰‹ï¼‰
        if(stateTarget==="scatter" && isOpen && !pinch && state!=="photo"){
          const dx=hx-lastHand.x;
          const dy=hy-lastHand.y;
          if(Math.abs(dx)+Math.abs(dy)>0.002){
            yawT += dx*(Math.PI*2.2);
            pitchT += dy*(Math.PI*1.1);

            const vx=(1-lm[17].x)-(1-lm[5].x);
            const vy=(lm[17].y)-(lm[5].y);
            const palmAngle=Math.atan2(vy,vx);
            rollT = Math.max(-0.22, Math.min(0.22, palmAngle*0.15));
          }
          lastHand={x:hx,y:hy,t:performance.now()};
        }else{
          rollT *= 0.92;
        }
      }

      async function startCamera(){
        if(!mpBase){
          toast("æ‰‹åŠ¿åº“æœªåŠ è½½ï¼Œå·²é™çº§ä¸ºè§¦æ§æ—‹è½¬ï¼ˆæ‹–åŠ¨å±å¹•æ—‹è½¬ï¼‰", 3000);
          return false;
        }
        if(camOn) return true;
        try{
          if(!navigator.mediaDevices?.getUserMedia){
            toast("å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ï¼šè¯·ç”¨ Safari/Chrome", 4500);
            return false;
          }
          if(!videoEl){
            videoEl=document.createElement("video");
            videoEl.setAttribute("playsinline","");
            videoEl.muted=true; videoEl.autoplay=true;
            videoEl.style.position="fixed";
            videoEl.style.left="-9999px";
            videoEl.style.top="-9999px";
            document.body.appendChild(videoEl);
          }
          stream = await navigator.mediaDevices.getUserMedia({
            video:{ facingMode:"user", width:{ideal:960}, height:{ideal:540} },
            audio:false
          });
          videoEl.srcObject=stream;
          await videoEl.play();

          if(!hands){
            hands=new window.Hands({ locateFile:(f)=> mpBase + f });
            hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.70, minTrackingConfidence:0.70 });
            hands.onResults(onHandResults);
          }
          if(!mpCamera){
            mpCamera=new window.Camera(videoEl, {
              onFrame: async ()=>{ if(hands) await hands.send({image:videoEl}); },
              width:960, height:540
            });
          }
          mpCamera.start();
          camOn=true;
          updateCamUI();
          toast("æ‘„åƒå¤´å·²å¼€å¯ï¼šå¯ä»¥ç”¨æ‰‹åŠ¿å•¦", 1600);
          return true;
        }catch(e){
          camOn=false;
          updateCamUI();
          toast("æ‘„åƒå¤´å¼€å¯å¤±è´¥ï¼šè¯·å…è®¸æƒé™ï¼›å°½é‡åˆ«åœ¨å¾®ä¿¡å†…æ‰“å¼€", 4500);
          return false;
        }
      }
      function stopCamera(){
        if(!camOn) return;
        try{ mpCamera?.stop?.(); }catch{}
        try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch{}
        stream=null; camOn=false;
        updateCamUI();
        toast("å·²å…³é—­æ‘„åƒå¤´", 1200);
      }

      // ---- èµ„æºåŠ è½½ä¸å¯åŠ¨ ----
      let booting=false, booted=false;
      async function boot(){
        if(booted) return true;
        if(booting) return false;
        booting=true;

        try{
          setStatus("æ­£åœ¨åŠ è½½ 3D å¼•æ“ï¼ˆThree.jsï¼‰â€¦");
          const okUrl = await loadFirst(THREE_SOURCES, "three");
          toast("Three.js å·²åŠ è½½ï¼š " + okUrl.replace(/^https?:\/\//,""), 1600);
          THREE = window.THREE;

          // åˆå§‹åŒ– 3D
          setStatus("æ­£åœ¨åˆå§‹åŒ– 3D åœºæ™¯â€¦");
          initThree();

          // å°è¯•åŠ è½½æ‰‹åŠ¿åº“ï¼ˆå¤±è´¥å°±é™çº§ï¼‰
          setStatus("æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«ï¼ˆå¯é€‰ï¼‰â€¦");
          try{
            mpBase = await loadMediaPipe();
            toast("æ‰‹åŠ¿åº“å·²å°±ç»ª", 1400);
          }catch(e){
            mpBase = null;
            toast("æ‰‹åŠ¿åº“åŠ è½½å¤±è´¥ï¼šå·²é™çº§ä¸ºè§¦æ§æ—‹è½¬ï¼ˆæ‹–åŠ¨å±å¹•ï¼‰", 3600);
          }

          booted=true;
          setStatus("å‡†å¤‡å°±ç»ªï¼šç‚¹â€œå¼€å§‹ä½“éªŒâ€æ’­æ”¾éŸ³ä¹å¹¶è¯·æ±‚æ‘„åƒå¤´ã€‚");
          return true;
        }catch(e){
          booted=false;
          setStatus("èµ„æºåŠ è½½å¤±è´¥ï¼šä½ çš„ç½‘ç»œå¯èƒ½æ‹¦æˆªäº† CDNã€‚\nè§£å†³ï¼šæ¢ç½‘ç»œï¼Œæˆ–æŠŠ three.min.js æ”¾åˆ°ä»“åº“ /libs ç›®å½•ã€‚");
          toast("èµ„æºåŠ è½½å¤±è´¥ï¼šè¯·æ¢ç½‘ç»œ/ç¨åé‡è¯•ï¼ˆæˆ–ä½¿ç”¨æœ¬åœ° libs å…œåº•ï¼‰", 5200);
          return false;
        }finally{
          booting=false;
        }
      }

      // UI ç»‘å®šï¼ˆå…ˆç»‘å®šï¼Œä¿è¯â€œæŒ‰é’®ä¸€å®šæœ‰ååº”â€ï¼‰
      camBtn.addEventListener("click", async ()=>{ camOn ? stopCamera() : await startCamera(); });
      musicBtn.addEventListener("click", ()=>{
        setMusic(!musicOn);
        updateMusicUI();
      });

      // ç‚¹å‡»ä»»æ„å¤„å°è¯•æ¢å¤éŸ³é¢‘
      window.addEventListener("pointerdown", ()=>{
        if(musicOn && bgm.paused) bgm.play().catch(()=>{});
      }, {passive:true});

      // â€œå¼€å§‹ä½“éªŒâ€æŒ‰é’®ï¼šæ— è®ºæˆåŠŸ/å¤±è´¥éƒ½æœ‰åé¦ˆ
      startBtn.addEventListener("click", async ()=>{
        startBtn.disabled = true;
        startBtn.textContent = "å¯åŠ¨ä¸­â€¦";
        setStatus("å·²æ”¶åˆ°ç‚¹å‡»ï¼šæ­£åœ¨å¯åŠ¨èµ„æº / éŸ³ä¹ / æ‘„åƒå¤´â€¦");

        // å…ˆç¡®ä¿ three åœºæ™¯å¯åŠ¨
        const ok = await boot();
        if(!ok){
          startBtn.disabled = false;
          startBtn.textContent = "å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰";
          return;
        }

        // éŸ³ä¹
        if(!musicOn){ setMusic(true); updateMusicUI(); }

        // æ‘„åƒå¤´ï¼ˆå¦‚æœæ‰‹åŠ¿åº“å¯ç”¨ï¼‰
        const camOK = await startCamera();
        if(!camOK){
          camBtn.classList.add("flash");
          setTimeout(()=>camBtn.classList.remove("flash"), 3200);
        }

        // è¿›å…¥åœºæ™¯
        startOverlay.classList.add("hide");
        startBtn.disabled = false;
        startBtn.textContent = "å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰";
      });

      // å…ˆå°è¯•åå°åŠ è½½ï¼ˆä¸å¼ºåˆ¶ï¼‰
      setStatus("æ­£åœ¨æ£€æŸ¥ç½‘ç»œå¹¶é¢„åŠ è½½èµ„æºâ€¦");
      boot();

      updateCamUI();
      updateMusicUI();
    })();
  </script>
</body>
</html>
